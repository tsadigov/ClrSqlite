using Community.CsharpSqlite.tree;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using i64 = System.Int64;
using u8 = System.Byte;
using u16 = System.UInt16;
using u32 = System.UInt32;
using u64 = System.UInt64;
using unsigned = System.UIntPtr;
using Pgno = System.UInt32;
using i32 = System.Int32;
using sqlite_int64 = System.Int64;
using yDbMask = System.Int32;
using Community.CsharpSqlite.Metadata;
using Community.CsharpSqlite.Paging;
using Community.CsharpSqlite.Os;
using Community.CsharpSqlite.Utils;

namespace Community.CsharpSqlite.Engine.Op
{
    using Operation = VdbeOp;
    using sqlite3_value = Engine.Mem;

    public static class TheRest
    {
        public static RuntimeException Exec(CPU cpu,OpCode opcode,VdbeOp pOp)
        {
            //public static RuntimeException Exec(Community.CsharpSqlite.Vdbe vdbe, SqliteEncoding encoding,OpCode opcode,VdbeOp pOp,Mem [] aMem,ref SqlResult rc) {

            List<Operation> lOp;

            var aMem = cpu.aMem;
            var vdbe = cpu.vdbe;
            var encoding = cpu.encoding;
            var db = vdbe.db;

            Mem pIn1 = null;
            ///1st input operand 
            Mem pIn2 = null;
            ///2nd input operand 
            Mem pIn3 = null;


            SqlResult rc=cpu.rc;
            switch (opcode) {


                ///<summary>
                ///
                ///What follows is a massive switch statement where each case implements a
                ///separate instruction in the virtual machine.  If we follow the usual
                ///indentation conventions, each case should be indented by 6 spaces.  But
                ///that is a lot of wasted space on the left margin.  So the code within
                ///</summary>
                ///the switch statement will break with convention and be flush">left. Another</param>
                ///big comment (similar to vdbe one) will mark the point in the code where</param>
                ///we transition back to normal indentation.</param>
                ///
                ///The formatting of each case is important.  The makefile for SQLite</param>
                ///generates two C files "opcodes.h" and "opcodes.c" by scanning vdbe</param>
                ///file looking for lines that begin with "case  OpCode.OP_".  The opcodes.h files</param>
                ///will be filled with #defines that give unique integer values to each</param>
                ///opcode and the opcodes.c file is filled with an array of strings where</param>
                ///each string is the symbolic name for the corresponding opcode.  If the</param>
                ///case statement is followed by a comment of the form "/# same as ... #/"</param>
                ///that comment is used to determine the particular value of the opcode.</param>
                ///
                ///Other keywords in the comment that follows each case are used to</param>
                ///construct the OPFLG_INITIALIZER value that initializes opcodeProperty[].</param>
                ///Keywords include: in1, in2, in3, ref2_prerelease, ref2, ref3.  See</param>
                ///mkopcodeh.awk script for additional information.</param>
                ///
                ///Documentation about VDBE opcodes is generated by scanning vdbe file">Documentation about VDBE opcodes is generated by scanning vdbe file</param>
                ///for lines of that contain "Opcode:".  That line and all subsequent</param>
                ///comment lines are used in the generation of the opcode.html documentation</param>
                ///file.</param>
                ///
                ///SUMMARY:</param>
                ///
                ///Formatting is important to scripts that scan vdbe file.</param>
                ///Do not deviate from the formatting style currently in use.</param>
                ///
                /// 

                ///
                ///<summary>
                ///Opcode:  HaltIfNull  P1 P2 P3 P4 *
                ///
                ///Check the value in register P3.  If it is NULL then Halt using
                ///parameter P1, P2, and P4 as if vdbe were a Halt instruction.  If the
                ///</summary>
                ///<param name="value in register P3 is not NULL, then vdbe routine is a no">op.</param>
                ///<param name=""></param>
                case OpCode.OP_HaltIfNull:
                    {
                        
                        ///in3 
                        pIn3 = aMem[pOp.p3];
                        if ((pIn3.flags & MemFlags.MEM_Null) == 0)
                            break;
                        ///Fall through into  OpCode.OP_Halt 
                        goto case OpCode.OP_Halt;
                    }
                ///
                ///<summary>
                ///Opcode:  Halt P1 P2 * P4 *
                ///
                ///Exit immediately.  All open cursors, etc are closed
                ///automatically.
                ///
                ///P1 is the result code returned by sqlite3_exec(), sqlite3_reset(),
                ///or sqlite3_finalize().  For a normal halt, vdbe should be SqlResult.SQLITE_OK (0).
                ///For errors, it can be some other value.  If P1!=0 then P2 will determine
                ///whether or not to rollback the current transaction.  Do not rollback
                ///if P2==OnConstraintError.OE_Fail. Do the rollback if P2==OnConstraintError.OE_Rollback.  If P2==OnConstraintError.OE_Abort,
                ///then back out all changes that have occurred during vdbe execution of the
                ///VDBE, but do not rollback the transaction.
                ///
                ///If P4 is not null then it is an error message string.
                ///
                ///There is an implied "Halt 0 0 0" instruction inserted at the very end of
                ///every program.  So a jump past the last instruction of the program
                ///is the same as executing Halt.
                ///
                ///</summary>
                case OpCode.OP_Halt:
                    {
                        pIn3 = aMem[pOp.p3];
                        if (pOp.p1 == (int)SqlResult.SQLITE_OK && vdbe.pFrame != null)
                        {
                            ///<param name="Halt the sub">program. Return control to the parent frame. </param>
                            VdbeFrame pFrame = vdbe.pFrame;
                            vdbe.pFrame = pFrame.pParent;
                            vdbe.nFrame--;
                            vdbeaux.sqlite3VdbeSetChanges(db, vdbe.nChange);
                            cpu.opcodeIndex = pFrame.sqlite3VdbeFrameRestore();
                            cpu.lastRowid = db.lastRowid;
                            if (pOp.p2 == (int)OnConstraintError.OE_Ignore)
                            {
                                ///<param name="Instruction pc is the  OpCode.OP_Program that invoked the sub">program </param>
                                ///<param name="currently being halted. If the p2 instruction of vdbe  OpCode.OP_Halt">currently being halted. If the p2 instruction of vdbe  OpCode.OP_Halt</param>
                                ///<param name="instruction is set to OnConstraintError.OE_Ignore, then the sub">program is throwing</param>
                                ///<param name="an IGNORE exception. In vdbe case jump to the address specified">an IGNORE exception. In vdbe case jump to the address specified</param>
                                ///<param name="as the p2 of the calling  OpCode.OP_Program.  ">as the p2 of the calling  OpCode.OP_Program.  </param>
                                cpu.opcodeIndex = vdbe.lOp[cpu.opcodeIndex].p2 - 1;
                            }
                            lOp = vdbe.lOp;
                            aMem = vdbe.aMem;
                            break;
                        }
                        vdbe.rc = (SqlResult)pOp.p1;
                        vdbe.errorAction = (OnConstraintError)pOp.p2;
                        vdbe.currentOpCodeIndex = cpu.opcodeIndex;
                        if (pOp.p4.z != null)
                        {
                            Debug.Assert(vdbe.rc != SqlResult.SQLITE_OK);
                            malloc_cs.sqlite3SetString(ref vdbe.zErrMsg, db, "%s", pOp.p4.z);
                            sqliteinth.testcase(sqliteinth.sqlite3GlobalConfig.xLog != null);
                            io.sqlite3_log(pOp.p1, "abort at %d in [%s]: %s", cpu.opcodeIndex, vdbe.zSql, pOp.p4.z);
                        }
                        else
                            if (vdbe.rc != 0)
                        {
                            sqliteinth.testcase(sqliteinth.sqlite3GlobalConfig.xLog != null);
                            io.sqlite3_log(pOp.p1, "constraint failed at %d in [%s]", cpu.opcodeIndex, vdbe.zSql);
                        }
                        rc = vdbe.sqlite3VdbeHalt();
                        Debug.Assert(rc == SqlResult.SQLITE_BUSY || rc == SqlResult.SQLITE_OK || rc == SqlResult.SQLITE_ERROR);
                        if (rc == SqlResult.SQLITE_BUSY)
                        {
                            vdbe.rc = rc = SqlResult.SQLITE_BUSY;
                        }
                        else
                        {
                            Debug.Assert(rc == SqlResult.SQLITE_OK || vdbe.rc == SqlResult.SQLITE_CONSTRAINT);
                            Debug.Assert(rc == SqlResult.SQLITE_OK || db.nDeferredCons > 0);
                            rc = vdbe.rc != 0 ? SqlResult.SQLITE_ERROR : SqlResult.SQLITE_DONE;
                        }
                        return RuntimeException.vdbe_return;
                    }



                ///
                ///<summary>
                ///Opcode: ResultRow P1 P2 * * *
                ///
                ///</summary>
                ///<param name="The registers P1 through P1+P2">1 contain a single row of</param>
                ///results. vdbe opcode causes the sqlite3_step() call to terminate</param>
                ///with an SQLITE_ROW return code and it sets up the sqlite3_stmt</param>
                ///structure to provide access to the top P1 values as the result</param>
                ///<param name="row.">row.</param>
                ///<param name=""></param>
                case OpCode.OP_ResultRow:
                    {
                        Debug.Assert(vdbe.nResColumn == pOp.p2);
                        Debug.Assert(pOp.p1 > 0);
                        Debug.Assert(pOp.p1 + pOp.p2 <= vdbe.nMem + 1);

                        rc = OpCode_ResultRow(vdbe,cpu.opcodeIndex, pOp.p1, pOp.p2, rc, aMem);
                        return RuntimeException.vdbe_return;
                    }
                ///<summary>
                ///Opcode: Concat P1 P2 P3 * *
                ///
                ///Add the text in register P1 onto the end of the text in
                ///register P2 and store the result in register P3.
                ///If either the P1 or P2 text are NULL then store NULL in P3.
                ///
                ///P3 = P2 || P1
                ///
                ///It is illegal for P1 and P3 to be the same register. Sometimes,
                ///if P3 is the same register as P2, the implementation is able
                ///to avoid a memcpy().
                ///
                ///</summary>
                case OpCode.OP_Concat:
                    {
                        ///
                        ///<summary>
                        ///same as TokenType.TK_CONCAT, in1, in2, ref3 
                        ///</summary>
                        i64 nByte;
                        pIn1 = aMem[pOp.p1];
                        pIn2 = aMem[pOp.p2];
                        cpu.pOut = aMem[pOp.p3];
                        Debug.Assert(pIn1 != cpu.pOut);
                        if (((pIn1.flags | pIn2.flags) & MemFlags.MEM_Null) != 0)
                        {
                            cpu.pOut.sqlite3VdbeMemSetNull();
                            break;
                        }
                        if (pIn1.ExpandBlob() != 0 || pIn2.ExpandBlob() != 0)
                            return RuntimeException.no_mem;
                        if (((pIn1.flags & (MemFlags.MEM_Str | MemFlags.MEM_Blob)) == 0) && vdbemem_cs.sqlite3VdbeMemStringify(pIn1, encoding) != 0)
                        {
                            return RuntimeException.no_mem;
                        }
                        // Stringify(pIn1, encoding);
                        if (((pIn2.flags & (MemFlags.MEM_Str | MemFlags.MEM_Blob)) == 0) && vdbemem_cs.sqlite3VdbeMemStringify(pIn2, encoding) != 0)
                        {
                            return RuntimeException.no_mem;
                        }
                        // Stringify(pIn2, encoding);
                        nByte = pIn1.n + pIn2.n;
                        if (nByte > db.aLimit[Globals.SQLITE_LIMIT_LENGTH])
                        {
                            return RuntimeException.too_big;
                        }
                        cpu.pOut.MemSetTypeFlag(MemFlags.MEM_Str);
                        //if ( sqlite3VdbeMemGrow( cpu.pOut, (int)nByte + 2, ( cpu.pOut == pIn2 ) ? 1 : 0 ) != 0 )
                        //{
                        //  return RuntimeException.no_mem;
                        //}
                        //if ( cpu.pOut != pIn2 )
                        //{
                        //  memcpy( cpu.pOut.z, pIn2.z, pIn2.n );
                        //}
                        //memcpy( &cpu.pOut.z[pIn2.n], pIn1.z, pIn1.n );
                        if (pIn2.z != null && pIn2.z.Length >= pIn2.n)
                            if (pIn1.z != null)
                                cpu.pOut.z = pIn2.z.Substring(0, pIn2.n) + (pIn1.n < pIn1.z.Length ? pIn1.z.Substring(0, pIn1.n) : pIn1.z);
                            else
                            {
                                if ((pIn1.flags & MemFlags.MEM_Blob) == 0)//String as Blob
                                {
                                    StringBuilder sb = new StringBuilder(pIn1.n);
                                    for (int i = 0; i < pIn1.n; i++)
                                        sb.Append((byte)pIn1.zBLOB[i]);
                                    cpu.pOut.z = pIn2.z.Substring(0, pIn2.n) + sb.ToString();
                                }
                                else
                                    // UTF-8 Blob
                                    cpu.pOut.z = pIn2.z.Substring(0, pIn2.n) + Encoding.UTF8.GetString(pIn1.zBLOB, 0, pIn1.zBLOB.Length);
                            }
                        else
                        {
                            cpu.pOut.zBLOB = malloc_cs.sqlite3Malloc(pIn1.n + pIn2.n);
                            Buffer.BlockCopy(pIn2.zBLOB, 0, cpu.pOut.zBLOB, 0, pIn2.n);
                            if (pIn1.zBLOB != null)
                                Buffer.BlockCopy(pIn1.zBLOB, 0, cpu.pOut.zBLOB, pIn2.n, pIn1.n);
                            else
                                for (int i = 0; i < pIn1.n; i++)
                                    cpu.pOut.zBLOB[pIn2.n + i] = (byte)pIn1.z[i];
                        }
                        //cpu.pOut.z[nByte] = 0;
                        //cpu.pOut.z[nByte + 1] = 0;
                        cpu.pOut.flags |= MemFlags.MEM_Term;
                        cpu.pOut.n = (int)nByte;
                        cpu.pOut.enc = encoding;
#if SQLITE_TEST
																																																																																																																																				              UPDATE_MAX_BLOBSIZE( cpu.pOut );
#endif
                        break;
                    }


                ///
                ///<summary>
                ///Opcode: Function P1 P2 P3 P4 P5
                ///
                ///Invoke a user function (P4 is a pointer to a Function structure that
                ///defines the function) with P5 arguments taken from register P2 and
                ///successors.  The result of the function is stored in register P3.
                ///Register P3 must not be one of the function inputs.
                ///
                ///</summary>
                ///<param name="P1 is a 32">bit bitmask indicating whether or not each argument to the</param>
                ///<param name="function was determined to be constant at compile time. If the first">function was determined to be constant at compile time. If the first</param>
                ///<param name="argument was constant then bit 0 of P1 is set. vdbe is used to determine">argument was constant then bit 0 of P1 is set. vdbe is used to determine</param>
                ///<param name="whether meta data associated with a user function argument using the">whether meta data associated with a user function argument using the</param>
                ///<param name="sqlite3_set_auxdata() API may be safely retained until the next">sqlite3_set_auxdata() API may be safely retained until the next</param>
                ///<param name="invocation of vdbe opcode.">invocation of vdbe opcode.</param>
                ///<param name=""></param>
                ///<param name="See also: AggStep and AggFinal">See also: AggStep and AggFinal</param>
                ///<param name=""></param>
                case OpCode.OP_Function:
                    {
                        int i;
                        Mem pArg;
                        sqlite3_context ctx = new sqlite3_context();
                        sqlite3_value[] apVal;
                        int n;
                        n = pOp.p5;
                        apVal = vdbe.apArg;
                        Debug.Assert(apVal != null || n == 0);
                        Debug.Assert(pOp.p3 > 0 && pOp.p3 <= vdbe.nMem);
                        cpu.pOut = aMem[pOp.p3];
                        vdbe.memAboutToChange(cpu.pOut);
                        Debug.Assert(n == 0 || (pOp.p2 > 0 && pOp.p2 + n <= vdbe.nMem + 1));
                        Debug.Assert(pOp.p3 < pOp.p2 || pOp.p3 >= pOp.p2 + n);
                        //pArg = aMem[pOp.p2];
                        for (i = 0; i < n; i++)//, pArg++)
                        {
                            pArg = aMem[pOp.p2 + i];
                            Debug.Assert(pArg.memIsValid());
                            apVal[i] = pArg;
                            Sqlite3.Deephemeralize(pArg);
                            Sqlite3.sqlite3VdbeMemStoreType(pArg);
                            Sqlite3.REGISTER_TRACE(vdbe, pOp.p2 + i, pArg);
                        }
                        Debug.Assert(pOp.p4type == P4Usage.P4_FUNCDEF || pOp.p4type == P4Usage.P4_VDBEFUNC);
                        if (pOp.p4type == P4Usage.P4_FUNCDEF)
                        {
                            ctx.pFunc = pOp.p4.pFunc;
                            ctx.pVdbeFunc = null;
                        }
                        else
                        {
                            ctx.pVdbeFunc = (Metadata.VdbeFunc)pOp.p4.pVdbeFunc;
                            ctx.pFunc = ctx.pVdbeFunc.pFunc;
                        }
                        ctx.s.flags = MemFlags.MEM_Null;
                        ctx.s.db = db;
                        ctx.s.xDel = null;
                        //ctx.s.zMalloc = null;
                        ///
                        ///<summary>
                        ///The output cell may already have a buffer allocated. Move
                        ///</summary>
                        ///<param name="the pointer to ctx.s so in case the user">function can use</param>
                        ///<param name="the already allocated buffer instead of allocating a new one.">the already allocated buffer instead of allocating a new one.</param>
                        ///<param name=""></param>
                        vdbemem_cs.sqlite3VdbeMemMove(ctx.s, cpu.pOut);
                        ctx.s.MemSetTypeFlag(MemFlags.MEM_Null);
                        ctx.isError = 0;
                        if ((ctx.pFunc.flags & FuncFlags.SQLITE_FUNC_NEEDCOLL) != 0)
                        {
                            Debug.Assert(cpu.opcodeIndex > 1);
                            //Debug.Assert(pOp > aOp);
                            Debug.Assert(vdbe.lOp[cpu.opcodeIndex - 1].p4type == P4Usage.P4_COLLSEQ);
                            //Debug.Assert(pOp[-1].p4type ==  P4Usage.P4_COLLSEQ);
                            Debug.Assert(vdbe.lOp[cpu.opcodeIndex - 1].OpCode == OpCode.OP_CollSeq);
                            //Debug.Assert(pOp[-1].opcode ==  OpCode.OP_CollSeq);
                            ctx.pColl = vdbe.lOp[cpu.opcodeIndex - 1].p4.pColl;
                            //ctx.pColl = pOp[-1].p4.pColl;
                        }
                        db.lastRowid = cpu.lastRowid;
                        ctx.pFunc.xFunc(ctx, n, apVal);
                        ///* IMP: R-24505-23230 */
                        cpu.lastRowid = db.lastRowid;
                        ///
                        ///<summary>
                        ///If any auxillary data functions have been called by vdbe user function,
                        ///</summary>
                        ///<param name="immediately call the destructor for any non">static values.</param>
                        ///<param name=""></param>
                        if (ctx.pVdbeFunc != null)
                        {
                            vdbeaux.sqlite3VdbeDeleteAuxData(ctx.pVdbeFunc, pOp.p1);
                            pOp.p4.pVdbeFunc = ctx.pVdbeFunc;
                            pOp.p4type = P4Usage.P4_VDBEFUNC;
                        }
                        //if ( db->mallocFailed )
                        //{
                        //  /* Even though a malloc() has failed, the implementation of the
                        //  ** user function may have called an sqlite3_result_XXX() function
                        //  ** to return a value. The following call releases any resources
                        //  ** associated with such a value.
                        //  */
                        //   &u.ag.ctx.s .sqlite3VdbeMemRelease();
                        //  return RuntimeException.no_mem;
                        //}
                        ///
                        ///<summary>
                        ///If the function returned an error, throw an exception 
                        ///</summary>
                        if (ctx.isError != 0)
                        {
                            malloc_cs.sqlite3SetString(ref vdbe.zErrMsg, db, vdbeapi.sqlite3_value_text(ctx.s));
                            rc = ctx.isError;
                        }
                        ///
                        ///<summary>
                        ///Copy the result of the function into register P3 
                        ///</summary>
                        vdbemem_cs.sqlite3VdbeChangeEncoding(ctx.s, encoding);
                        vdbemem_cs.sqlite3VdbeMemMove(cpu.pOut, ctx.s);
                        if (cpu.pOut.IsTooBig())
                        {
                            return RuntimeException.too_big;
                        }
#if FALSE
																																																																																																																																				  /* The app-defined function has done something that as caused vdbe
  ** statement to expire.  (Perhaps the function called sqlite3_exec()
  ** with a CREATE TABLE statement.)
  */
  if( p.expired ) rc = SQLITE_ABORT;
#endif
                        Sqlite3.REGISTER_TRACE(vdbe, pOp.p3, cpu.pOut);
#if SQLITE_TEST
																																																																																																																																				              UPDATE_MAX_BLOBSIZE( cpu.pOut );
#endif
                        break;
                    }





                ///
                ///<summary>
                ///Opcode: Permutation * * * P4 *
                ///
                ///Set the permutation used by the  OpCode.OP_Compare operator to be the array
                ///of integers in P4.
                ///
                ///The permutation is only valid until the next  OpCode.OP_Permutation,  OpCode.OP_Compare,
                ///OP_Halt, or OpCode.OP_ResultRow.  Typically the  OpCode.OP_Permutation should occur
                ///immediately prior to the  OpCode.OP_Compare.
                ///
                ///</summary>
                case OpCode.OP_Permutation:
                    {
                        Debug.Assert(pOp.p4type == P4Usage.P4_INTARRAY);
                        Debug.Assert(pOp.p4.ai != null);
                        cpu.aPermute = pOp.p4.ai;
                        break;
                    }
                ///
                ///<summary>
                ///Opcode: Compare P1 P2 P3 P4 *
                ///
                ///</summary>
                ///<param name="Compare two vectors of registers in reg(P1)..reg(P1+P3">1) (call vdbe</param>
                ///<param name="vector "A") and in reg(P2)..reg(P2+P3">1) ("B").  Save the result of</param>
                ///<param name="the comparison for use by the next  OpCode.OP_Jump instruct.">the comparison for use by the next  OpCode.OP_Jump instruct.</param>
                ///<param name=""></param>
                ///<param name="P4 is a KeyInfo structure that defines collating sequences and sort">P4 is a KeyInfo structure that defines collating sequences and sort</param>
                ///<param name="orders for the comparison.  The permutation applies to registers">orders for the comparison.  The permutation applies to registers</param>
                ///<param name="only.  The KeyInfo elements are used sequentially.">only.  The KeyInfo elements are used sequentially.</param>
                ///<param name=""></param>
                ///<param name="The comparison is a sort comparison, so NULLs compare equal,">The comparison is a sort comparison, so NULLs compare equal,</param>
                ///<param name="NULLs are less than numbers, numbers are less than strings,">NULLs are less than numbers, numbers are less than strings,</param>
                ///<param name="and strings are less than blobs.">and strings are less than blobs.</param>
                ///<param name=""></param>
                case OpCode.OP_Compare:
                    {
                        OCode_Compare(vdbe,pOp, aMem, ref cpu.iCompare, ref cpu.aPermute);
                        break;
                    }

                ///
                ///<summary>
                ///Opcode: Column P1 P2 P3 P4 *
                ///
                ///Interpret the data that cursor P1 points to as a structure built using
                ///the MakeRecord instruction.  (See the MakeRecord opcode for additional
                ///</summary>
                ///<param name="information about the format of the data.)  Extract the P2">th column</param>
                ///<param name="from vdbe record.  If there are less that (P2+1)">from vdbe record.  If there are less that (P2+1)</param>
                ///<param name="values in the record, extract a NULL.">values in the record, extract a NULL.</param>
                ///<param name=""></param>
                ///<param name="The value extracted is stored in register P3.">The value extracted is stored in register P3.</param>
                ///<param name=""></param>
                ///<param name="If the column contains fewer than P2 fields, then extract a NULL.  Or,">If the column contains fewer than P2 fields, then extract a NULL.  Or,</param>
                ///<param name="if the P4 argument is a  P4Usage.P4_MEM use the value of the P4 argument as">if the P4 argument is a  P4Usage.P4_MEM use the value of the P4 argument as</param>
                ///<param name="the result.">the result.</param>
                ///<param name=""></param>
                ///<param name="If the OPFLAG_CLEARCACHE bit is set on P5 and P1 is a pseudo">table cursor,</param>
                ///<param name="then the cache of the cursor is reset prior to extracting the column.">then the cache of the cursor is reset prior to extracting the column.</param>
                ///<param name="The first  OpCode.OP_Column against a pseudo">table after the value of the content</param>
                ///<param name="register has changed should have vdbe bit set.">register has changed should have vdbe bit set.</param>
                ///<param name=""></param>
                case OpCode.OP_Column:
                    {
                        rc = OpCode_Column(vdbe,pOp, rc, db, encoding, aMem);
                        
                        switch (rc) { }
                        break;
                    }
                ///Opcode: MakeRecord P1 P2 P3 P4 *
                ///
                ///Convert P2 registers beginning with P1 into the [record format]
                ///use as a data record in a database table or as a key
                ///in an index.  The  OpCode.OP_Column opcode can decode the record later.
                ///
                ///P4 may be a string that is P2 characters long.  The nth character of the
                ///string indicates the column affinity that should be used for the nth
                ///field of the index key.
                ///
                ///The mapping from character to affinity is given by the SQLITE_AFF_
                ///macros defined in sqliteInt.h.
                ///
                ///If P4 is NULL then all index fields have the affinity NONE.
                case OpCode.OP_MakeRecord:
                    {
                        ///A buffer to hold the data for the new record 
                        byte[] zNewRecord;
                        Mem pRec;
                        ///The new record 
                        u64 nData;
                        ///Number of bytes of data space 
                        int nHdr;
                        ///Number of bytes of header space 
                        i64 nByte;
                        ///Data space required for vdbe record 
                        int nZero;
                        ///Number of zero bytes at the end of the record 
                        int nVarint;
                        ///Number of bytes in a varint 
                        u32 serial_type;
                        ///Type field 
                        //Mem pData0;            /* First field to be combined into the record */
                        //Mem pLast;             /* Last field of the record */
                        int nField;
                        ///Number of fields in the record 
                        string zAffinity;
                        ///The affinity string for the record 
                        int file_format;
                        ///File format to use for encoding 
                        int i;
                        ///Space used in zNewRecord[] 
                        int len;
                        ///Length of a field 
                        ///Assuming the record contains N fields, the record format looks
                        ///like vdbe:
                        ///<param name=""></param>
                        ///<param name="| hdr">1 |</param>
                        ///<param name=""></param>
                        ///<param name=""></param>
                        ///<param name="Data(0) is taken from register P1.  Data(1) comes from register P1+1">Data(0) is taken from register P1.  Data(1) comes from register P1+1</param>
                        ///<param name="and so froth.">and so froth.</param>
                        ///<param name=""></param>
                        ///<param name="Each type field is a varint representing the serial type of the">Each type field is a varint representing the serial type of the</param>
                        ///<param name="corresponding data element (see sqlite3VdbeSerialType()). The">corresponding data element (see sqlite3VdbeSerialType()). The</param>
                        ///<param name="hdr">size field is also a varint which is the offset from the beginning</param>
                        ///<param name="of the record to data0.">of the record to data0.</param>
                        nData = 0;
                        ///Number of bytes of data space 
                        nHdr = 0;
                        ///Number of bytes of header space 
                        nZero = 0;
                        ///Number of zero bytes at the end of the record 
                        nField = pOp.p1;
                        zAffinity = (pOp.p4.z == null || pOp.p4.z.Length == 0) ? "" : pOp.p4.z;
                        Debug.Assert(nField > 0 && pOp.p2 > 0 && pOp.p2 + nField <= vdbe.nMem + 1);
                        //pData0 = aMem[nField];
                        nField = pOp.p2;
                        //pLast =  pData0[nField - 1];
                        file_format = vdbe.minWriteFileFormat;
                        ///Identify the output register 
                        Debug.Assert(pOp.p3 < pOp.p1 || pOp.p3 >= pOp.p1 + pOp.p2);
                        cpu.pOut = aMem[pOp.p3];
                        vdbe.memAboutToChange(cpu.pOut);
                        ///Loop through the elements that will make up the record to figure
                        ///out how much space is required for the new record.
                        //for (pRec = pData0; pRec <= pLast; pRec++)
                        for (int pD0 = 0; pD0 < nField; pD0++)
                        {
                            pRec = vdbe.aMem[pOp.p1 + pD0];
                            Debug.Assert(pRec.memIsValid());
                            if (pD0 < zAffinity.Length && zAffinity[pD0] != '\0')
                            {
                                pRec.applyAffinity((char)zAffinity[pD0], encoding);
                            }
                            if ((pRec.flags & MemFlags.MEM_Zero) != 0 && pRec.n > 0)
                            {
                                pRec.sqlite3VdbeMemExpandBlob();
                            }
                            serial_type = vdbeaux.sqlite3VdbeSerialType(pRec, file_format);
                            len = (int)vdbeaux.sqlite3VdbeSerialTypeLen(serial_type);
                            nData += (u64)len;
                            nHdr += utilc.sqlite3VarintLen(serial_type);
                            if ((pRec.flags & MemFlags.MEM_Zero) != 0)
                            {
                                ///
                                ///<summary>
                                ///</summary>
                                ///<param name="Only pure zero">filled BLOBs can be input to vdbe Opcode.</param>
                                ///<param name="We do not allow blobs with a prefix and a zero">filled tail. </param>
                                nZero += pRec.u.nZero;
                            }
                            else
                                if (len != 0)
                            {
                                nZero = 0;
                            }
                        }
                        ///
                        ///<summary>
                        ///Add the initial header varint and total the size 
                        ///</summary>
                        nHdr += nVarint = utilc.sqlite3VarintLen((u64)nHdr);
                        if (nVarint < utilc.sqlite3VarintLen((u64)nHdr))
                        {
                            nHdr++;
                        }
                        nByte = (i64)((u64)nHdr + nData - (u64)nZero);

                        /// !!! ATTENTIOAN !!!  may have broken something here
                        if (nByte > db.aLimit[Globals.SQLITE_LIMIT_LENGTH])
                        {
                            return RuntimeException.too_big;
                        }
                        ///
                        ///<summary>
                        ///Make sure the output register has a buffer large enough to store
                        ///the new record. The output register (pOp.p3) is not allowed to
                        ///be one of the input registers (because the following call to
                        ///sqlite3VdbeMemGrow() could clobber the value before it is used).
                        ///
                        ///</summary>
                        //if ( sqlite3VdbeMemGrow( cpu.pOut, (int)nByte, 0 ) != 0 )
                        //{
                        //  return RuntimeException.no_mem;
                        //}
                        zNewRecord = malloc_cs.sqlite3Malloc((int)nByte);
                        // (u8 )cpu.pOut.z;
                        ///
                        ///<summary>
                        ///Write the record 
                        ///</summary>
                        i = utilc.putVarint32(zNewRecord, nHdr);
                        for (int pD0 = 0; pD0 < nField; pD0++)//for (pRec = pData0; pRec <= pLast; pRec++)
                        {
                            pRec = vdbe.aMem[pOp.p1 + pD0];
                            serial_type = vdbeaux.sqlite3VdbeSerialType(pRec, file_format);
                            i += utilc.putVarint32(zNewRecord, i, (int)serial_type);
                            ///
                            ///<summary>
                            ///serial type 
                            ///</summary>
                        }
                        for (int pD0 = 0; pD0 < nField; pD0++)//for (pRec = pData0; pRec <= pLast; pRec++)
                        {
                            ///
                            ///<summary>
                            ///serial data 
                            ///</summary>
                            pRec = vdbe.aMem[pOp.p1 + pD0];
                            i += (int)vdbeaux.sqlite3VdbeSerialPut(zNewRecord, i, (int)nByte - i, pRec, file_format);
                        }
                        //TODO -- Remove vdbe  for testing Debug.Assert( i == nByte );
                        Debug.Assert(pOp.p3 > 0 && pOp.p3 <= vdbe.nMem);
                        cpu.pOut.zBLOB = zNewRecord;
                        cpu.pOut.z = null;
                        cpu.pOut.n = (int)nByte;
                        cpu.pOut.flags = MemFlags.MEM_Blob | MemFlags.MEM_Dyn;
                        cpu.pOut.xDel = null;
                        if (nZero != 0)
                        {
                            cpu.pOut.u.nZero = nZero;
                            cpu.pOut.flags |= MemFlags.MEM_Zero;
                        }
                        cpu.pOut.enc = SqliteEncoding.UTF8;
                        ///
                        ///<summary>
                        ///In case the blob is ever converted to text 
                        ///</summary>
                        Sqlite3.REGISTER_TRACE(vdbe, pOp.p3, cpu.pOut);
#if SQLITE_TEST
																																																																																																																																				              UPDATE_MAX_BLOBSIZE( cpu.pOut );
#endif
                        break;
                    }


                ///
                ///<summary>
                ///Opcode: Found P1 P2 P3 P4 *
                ///
                ///If P4==0 then register P3 holds a blob constructed by MakeRecord.  If
                ///P4>0 then register P3 is the first of P4 registers that form an unpacked
                ///record.
                ///
                ///Cursor P1 is on an index btree.  If the record identified by P3 and P4
                ///is a prefix of any entry in P1 then a jump is made to P2 and
                ///P1 is left pointing at the matching entry.
                ///
                ///</summary>
                ///
                ///<summary>
                ///Opcode: NotFound P1 P2 P3 P4 *
                ///
                ///If P4==0 then register P3 holds a blob constructed by MakeRecord.  If
                ///P4>0 then register P3 is the first of P4 registers that form an unpacked
                ///record.
                ///
                ///Cursor P1 is on an index btree.  If the record identified by P3 and P4
                ///is not the prefix of any entry in P1 then a jump is made to P2.  If P1 
                ///does contain an entry whose prefix matches the P3/P4 record then control
                ///falls through to the next instruction and P1 is left pointing at the
                ///matching entry.
                ///
                ///See also: Found, NotExists, IsUnique
                ///
                ///</summary>
                case OpCode.OP_NotFound:
                ///
                ///<summary>
                ///jump, in3 
                ///</summary>
                case OpCode.OP_Found:
                    {
                        ///
                        ///<summary>
                        ///jump, in3 
                        ///</summary>
                        int alreadyExists;
                        VdbeCursor pC;
                        int res = 0;
                        UnpackedRecord pIdxKey;
                        UnpackedRecord r = new UnpackedRecord();
                        UnpackedRecord aTempRec = new UnpackedRecord();
                        //char aTempRec[ROUND8(sizeof(UnpackedRecord)) + sizeof(Mem)*3 + 7];
#if SQLITE_TEST
#if !TCLSH
																																																																																																																																				              sqlite3_found_count++;
#else
																																																																																																																																				              sqlite3_found_count.iValue++;
#endif
#endif
                        alreadyExists = 0;
                        Debug.Assert(pOp.p1 >= 0 && pOp.p1 < vdbe.nCursor);
                        Debug.Assert(pOp.p4type == P4Usage.P4_INT32);
                        pC = vdbe.OpenCursors[pOp.p1];
                        Debug.Assert(pC != null);
                        pIn3 = aMem[pOp.p3];
                        if (Sqlite3.ALWAYS(pC.pCursor != null))
                        {
                            Debug.Assert(!pC.isTable);
                            if (pOp.p4.i > 0)
                            {
                                r.pKeyInfo = pC.pKeyInfo;
                                r.nField = (u16)pOp.p4.i;
                                r.aMem = new Mem[r.nField];
                                for (int i = 0; i < r.aMem.Length; i++)
                                {
                                    r.aMem[i] = aMem[pOp.p3 + i];
#if SQLITE_DEBUG
																																																																																																																																																																																																															                    Debug.Assert( memIsValid( r.aMem[i] ) );
#endif
                                }
                                r.flags = UnpackedRecordFlags.UNPACKED_PREFIX_MATCH;
                                pIdxKey = r;
                            }
                            else
                            {
                                Debug.Assert((pIn3.flags & MemFlags.MEM_Blob) != 0);
                                Debug.Assert((pIn3.flags & MemFlags.MEM_Zero) == 0);
                                ///
                                ///<summary>
                                ///zeroblobs already expanded 
                                ///</summary>
                                pIdxKey = vdbeaux.sqlite3VdbeRecordUnpack(pC.pKeyInfo, pIn3.n, pIn3.zBLOB, aTempRec, 0);
                                //sizeof( aTempRec ) );
                                if (pIdxKey == null)
                                {
                                    return RuntimeException.no_mem;
                                }
                                pIdxKey.flags |= UnpackedRecordFlags.UNPACKED_PREFIX_MATCH;
                            }
                            rc = pC.pCursor.sqlite3BtreeMovetoUnpacked(pIdxKey, 0, 0, ref res);
                            if (pOp.p4.i == 0)
                            {
                                vdbeaux.sqlite3VdbeDeleteUnpackedRecord(pIdxKey);
                            }
                            if (rc != SqlResult.SQLITE_OK)
                            {
                                break;
                            }
                            alreadyExists = (res == 0) ? 1 : 0;
                            pC.deferredMoveto = false;
                            pC.cacheStatus = Sqlite3.CACHE_STALE;
                        }
                        if (pOp.OpCode == OpCode.OP_Found)
                        {
                            if (alreadyExists != 0)
                                cpu.opcodeIndex = pOp.p2 - 1;
                        }
                        else
                        {
                            if (0 == alreadyExists)
                                cpu.opcodeIndex = pOp.p2 - 1;
                        }
                        break;
                    }
                ///
                ///<summary>
                ///Opcode: IsUnique P1 P2 P3 P4 *
                ///
                ///</summary>
                ///<param name="Cursor P1 is open on an index b"> that is to say, a btree which</param>
                ///<param name="no data and where the key are records generated by  OpCode.OP_MakeRecord with">no data and where the key are records generated by  OpCode.OP_MakeRecord with</param>
                ///<param name="the list field being the integer ROWID of the entry that the index">the list field being the integer ROWID of the entry that the index</param>
                ///<param name="entry refers to.">entry refers to.</param>
                ///<param name=""></param>
                ///<param name="The P3 register contains an integer record number. Call vdbe record">The P3 register contains an integer record number. Call vdbe record</param>
                ///<param name="number R. Register P4 is the first in a set of N contiguous registers">number R. Register P4 is the first in a set of N contiguous registers</param>
                ///<param name="that make up an unpacked index key that can be used with cursor P1.">that make up an unpacked index key that can be used with cursor P1.</param>
                ///<param name="The value of N can be inferred from the cursor. N includes the rowid">The value of N can be inferred from the cursor. N includes the rowid</param>
                ///<param name="value appended to the end of the index record. vdbe rowid value may">value appended to the end of the index record. vdbe rowid value may</param>
                ///<param name="or may not be the same as R.">or may not be the same as R.</param>
                ///<param name=""></param>
                ///<param name="If any of the N registers beginning with register P4 contains a NULL">If any of the N registers beginning with register P4 contains a NULL</param>
                ///<param name="value, jump immediately to P2.">value, jump immediately to P2.</param>
                ///<param name=""></param>
                ///<param name="Otherwise, vdbe instruction checks if cursor P1 contains an entry">Otherwise, vdbe instruction checks if cursor P1 contains an entry</param>
                ///<param name="where the first (N">1) fields match but the rowid value at the end</param>
                ///<param name="of the index entry is not R. If there is no such entry, control jumps">of the index entry is not R. If there is no such entry, control jumps</param>
                ///<param name="to instruction P2. Otherwise, the rowid of the conflicting index">to instruction P2. Otherwise, the rowid of the conflicting index</param>
                ///<param name="entry is copied to register P3 and control falls through to the next">entry is copied to register P3 and control falls through to the next</param>
                ///<param name="instruction.">instruction.</param>
                ///<param name=""></param>
                ///<param name="See also: NotFound, NotExists, Found">See also: NotFound, NotExists, Found</param>
                ///<param name=""></param>
                case OpCode.OP_IsUnique:
                    {
                        ///
                        ///<summary>
                        ///jump, in3 
                        ///</summary>
                        u16 ii;
                        VdbeCursor pCx = new VdbeCursor();
                        BtCursor pCrsr;
                        u16 nField;
                        Mem[] aMx;
                        UnpackedRecord r;
                        ///
                        ///<summary>
                        ///</summary>
                        ///<param name="B">Tree index search key </param>
                        i64 R;
                        ///
                        ///<summary>
                        ///Rowid stored in register P3 
                        ///</summary>
                        r = new UnpackedRecord();
                        pIn3 = aMem[pOp.p3];
                        //aMx = aMem[pOp->p4.i];
                        ///
                        ///<summary>
                        ///Assert that the values of parameters P1 and P4 are in range. 
                        ///</summary>
                        Debug.Assert(pOp.p4type == P4Usage.P4_INT32);
                        Debug.Assert(pOp.p4.i > 0 && pOp.p4.i <= vdbe.nMem);
                        Debug.Assert(pOp.p1 >= 0 && pOp.p1 < vdbe.nCursor);
                        ///
                        ///<summary>
                        ///Find the index cursor. 
                        ///</summary>
                        pCx = vdbe.OpenCursors[pOp.p1];
                        Debug.Assert(!pCx.deferredMoveto);
                        pCx.seekResult = 0;
                        pCx.cacheStatus = Sqlite3.CACHE_STALE;
                        pCrsr = pCx.pCursor;
                        ///
                        ///<summary>
                        ///If any of the values are NULL, take the jump. 
                        ///</summary>
                        nField = pCx.pKeyInfo.nField;
                        aMx = new Mem[nField + 1];
                        for (ii = 0; ii < nField; ii++)
                        {
                            aMx[ii] = aMem[pOp.p4.i + ii];
                            if ((aMx[ii].flags & MemFlags.MEM_Null) != 0)
                            {
                                cpu.opcodeIndex = pOp.p2 - 1;
                                pCrsr = null;
                                break;
                            }
                        }
                        aMx[nField] = new Mem();
                        //Debug.Assert( ( aMx[nField].flags & MEM.MEM_Null ) == 0 );
                        if (pCrsr != null)
                        {
                            ///
                            ///<summary>
                            ///Populate the index search key. 
                            ///</summary>
                            r.pKeyInfo = pCx.pKeyInfo;
                            r.nField = (ushort)(nField + 1);
                            r.flags = UnpackedRecordFlags.UNPACKED_PREFIX_SEARCH;
                            r.aMem = aMx;
#if SQLITE_DEBUG
																																																																																																																																																													                {
                  int i;
                  for ( i = 0; i < r.nField; i++ )
                    Debug.Assert( memIsValid( r.aMem[i] ) );
                }
#endif
                            ///
                            ///<summary>
                            ///Extract the value of R from register P3. 
                            ///</summary>

                            pIn3.sqlite3VdbeMemIntegerify();
                            R = pIn3.u.i;
                            ///
                            ///<summary>
                            ///</summary>
                            ///<param name="Search the B">Tree index. If no conflicting record is found, jump</param>
                            ///<param name="to P2. Otherwise, copy the rowid of the conflicting record to">to P2. Otherwise, copy the rowid of the conflicting record to</param>
                            ///<param name="register P3 and fall through to the next instruction.  ">register P3 and fall through to the next instruction.  </param>
                            rc = pCrsr.sqlite3BtreeMovetoUnpacked(r, 0, 0, ref pCx.seekResult);
                            if ((r.flags & UnpackedRecordFlags.UNPACKED_PREFIX_SEARCH) != 0 || r.rowid == R)
                            {
                                cpu.opcodeIndex = pOp.p2 - 1;
                            }
                            else
                            {
                                pIn3.u.i = r.rowid;
                            }
                        }
                        break;
                    }
                ///
                ///<summary>
                ///Opcode: NotExists P1 P2 P3 * *
                ///
                ///Use the content of register P3 as an integer key.  If a record
                ///with that key does not exist in table of P1, then jump to P2.
                ///If the record does exist, then fall through.  The cursor is left
                ///pointing to the record if it exists.
                ///
                ///The difference between vdbe operation and NotFound is that vdbe
                ///operation assumes the key is an integer and that P1 is a table whereas
                ///NotFound assumes key is a blob constructed from MakeRecord and
                ///P1 is an index.
                ///
                ///See also: Found, NotFound, IsUnique
                ///
                ///</summary>
                case OpCode.OP_NotExists:
                    {
                        ///
                        ///<summary>
                        ///jump, in3 
                        ///</summary>
                        VdbeCursor pC;
                        BtCursor pCrsr;
                        int res;
                        i64 iKey;
                        pIn3 = aMem[pOp.p3];
                        Debug.Assert((pIn3.flags & MemFlags.MEM_Int) != 0);
                        Debug.Assert(pOp.p1 >= 0 && pOp.p1 < vdbe.nCursor);
                        pC = vdbe.OpenCursors[pOp.p1];
                        Debug.Assert(pC != null);
                        Debug.Assert(pC.isTable);
                        Debug.Assert(pC.pseudoTableReg == 0);
                        pCrsr = pC.pCursor;
                        if (pCrsr != null)
                        {
                            res = 0;
                            iKey = pIn3.u.i;
                            rc = pCrsr.sqlite3BtreeMovetoUnpacked(null, (long)iKey, 0, ref res);
                            pC.lastRowid = pIn3.u.i;
                            pC.rowidIsValid = res == 0 ? true : false;
                            pC.nullRow = false;
                            pC.cacheStatus = Sqlite3.CACHE_STALE;
                            pC.deferredMoveto = false;
                            if (res != 0)
                            {
                                cpu.opcodeIndex = pOp.p2 - 1;
                                Debug.Assert(!pC.rowidIsValid);
                            }
                            pC.seekResult = res;
                        }
                        else
                        {
                            ///
                            ///<summary>
                            ///vdbe happens when an attempt to open a read cursor on the
                            ///sqlite_master table returns SQLITE_EMPTY.
                            ///
                            ///</summary>
                            cpu.opcodeIndex = pOp.p2 - 1;
                            Debug.Assert(!pC.rowidIsValid);
                            pC.seekResult = 0;
                        }
                        break;
                    }

                ///
                ///<summary>
                ///Opcode: NewRowid P1 P2 P3 * *
                ///
                ///Get a new integer record number (a.k.a "rowid") used as the key to a table.
                ///The record number is not previously used as a key in the database
                ///table that cursor P1 points to.  The new record number is written
                ///written to register P2.
                ///
                ///If P3>0 then P3 is a register in the root frame of vdbe VDBE that holds 
                ///the largest previously generated record number. No new record numbers are
                ///allowed to be less than vdbe value. When vdbe value reaches its maximum, 
                ///an SQLITE_FULL error is generated. The P3 register is updated with the '
                ///generated record number. vdbe P3 mechanism is used to help implement the
                ///AUTOINCREMENT feature.
                ///
                ///</summary>
                case OpCode.OP_NewRowid:
                    #region generate rowid
                    {
                        ///</summary>
                        ///<param name="out2">prerelease </param>
                        i64 v;
                        ///The new rowid 
                        VdbeCursor pC;
                        ///Cursor of table to get the new rowid 
                        int res;
                        ///Result of an sqlite3BtreeLast() 
                        int cnt;
                        ///Counter to limit the number of searches 
                        Mem pMem;
                        ///Register holding largest rowid for AUTOINCREMENT 
                        VdbeFrame rootFrame;
                        ///Root frame of VDBE 
                        v = 0;
                        res = 0;
                        Debug.Assert(pOp.p1 >= 0 && pOp.p1 < vdbe.nCursor);
                        pC = vdbe.OpenCursors[pOp.p1];
                        Debug.Assert(pC != null);
                        if (Sqlite3.NEVER(pC.pCursor == null))
                        {
                            ///The zero initialization above is all that is needed 
                        }
                        else
                        {
                            ///The next rowid or record number (different terms for the same
                            ///<param name="thing) is obtained in a two">step algorithm.</param>
                            ///<param name=""></param>
                            ///<param name="First we attempt to find the largest existing rowid and add one">First we attempt to find the largest existing rowid and add one</param>
                            ///<param name="to that.  But if the largest existing rowid is already the maximum">to that.  But if the largest existing rowid is already the maximum</param>
                            ///<param name="positive integer, we have to fall through to the second">positive integer, we have to fall through to the second</param>
                            ///<param name="probabilistic algorithm">probabilistic algorithm</param>
                            ///<param name=""></param>
                            ///<param name="The second algorithm is to select a rowid at random and see if">The second algorithm is to select a rowid at random and see if</param>
                            ///<param name="it already exists in the table.  If it does not exist, we have">it already exists in the table.  If it does not exist, we have</param>
                            ///<param name="succeeded.  If the random rowid does exist, we select a new one">succeeded.  If the random rowid does exist, we select a new one</param>
                            ///<param name="and try again, up to 100 times.">and try again, up to 100 times.</param>
                            ///<param name=""></param>
                            Debug.Assert(pC.isTable);
#if SQLITE_32BIT_ROWID
																																																																																																																																																													const int MAX_ROWID = i32.MaxValue;//   define MAX_ROWID 0x7fffffff
#else
                            ///
                            ///<summary>
                            ///Some compilers complain about constants of the form 0x7fffffffffffffff.
                            ///Others complain about 0x7ffffffffffffffffLL.  The following macro seems
                            ///to provide the constant while making all compilers happy.
                            ///</summary>
                            const long MAX_ROWID = i64.MaxValue;
                            // (i64)( (((u64)0x7fffffff)<<32) | (u64)0xffffffff )
#endif
                            if (!pC.useRandomRowid)
                            {
                                v = pC.pCursor.sqlite3BtreeGetCachedRowid();
                                if (v == 0)
                                {
                                    rc = pC.pCursor.sqlite3BtreeLast(ref res);
                                    if (rc != SqlResult.SQLITE_OK)
                                    {
                                        return RuntimeException.abort_due_to_error;
                                    }
                                    if (res != 0)
                                    {
                                        v = 1;
                                        ///
                                        ///<summary>
                                        ///</summary>
                                        ///<param name="IMP: R">48074 </param>
                                    }
                                    else
                                    {
                                        Debug.Assert(pC.pCursor.sqlite3BtreeCursorIsValid());
                                        rc = pC.pCursor.sqlite3BtreeKeySize(ref v);
                                        Debug.Assert(rc == SqlResult.SQLITE_OK);
                                        ///
                                        ///<summary>
                                        ///Cannot fail following BtreeLast() 
                                        ///</summary>
                                        if (v == MAX_ROWID)
                                        {
                                            pC.useRandomRowid = true;
                                        }
                                        else
                                        {
                                            v++;
                                            ///
                                            ///<summary>
                                            ///</summary>
                                            ///<param name="IMP: R">34987 </param>
                                        }
                                    }
                                }
#if !SQLITE_OMIT_AUTOINCREMENT
                                if (pOp.p3 != 0)
                                {
                                    ///
                                    ///<summary>
                                    ///Assert that P3 is a valid memory cell. 
                                    ///</summary>
                                    Debug.Assert(pOp.p3 > 0);
                                    if (vdbe.pFrame != null)
                                    {
                                        rootFrame = vdbe.pFrame.GetRoot();
                                        ///
                                        ///<summary>
                                        ///Assert that P3 is a valid memory cell. 
                                        ///</summary>
                                        Debug.Assert(pOp.p3 <= rootFrame.nMem);
                                        pMem = rootFrame.aMem[pOp.p3];
                                    }
                                    else
                                    {
                                        ///
                                        ///<summary>
                                        ///Assert that P3 is a valid memory cell. 
                                        ///</summary>
                                        Debug.Assert(pOp.p3 <= vdbe.nMem);
                                        pMem = aMem[pOp.p3];
                                        vdbe.memAboutToChange(pMem);
                                    }
                                    Debug.Assert(pMem.memIsValid());
                                    Sqlite3.REGISTER_TRACE(vdbe, pOp.p3, pMem);
                                    pMem.sqlite3VdbeMemIntegerify();
                                    Debug.Assert((pMem.flags & MemFlags.MEM_Int) != 0);
                                    ///
                                    ///<summary>
                                    ///mem(P3) holds an integer 
                                    ///</summary>
                                    if (pMem.u.i == MAX_ROWID || pC.useRandomRowid)
                                    {
                                        rc = SqlResult.SQLITE_FULL;
                                        ///
                                        ///<summary>
                                        ///</summary>
                                        ///<param name="IMP: R">61338 </param>
                                        return RuntimeException.abort_due_to_error;
                                    }
                                    if (v < (pMem.u.i + 1))
                                    {
                                        v = (int)(pMem.u.i + 1);
                                    }
                                    pMem.u.i = (long)v;
                                }
#endif
                                pC.pCursor.sqlite3BtreeSetCachedRowid(v < MAX_ROWID ? v + 1 : 0);
                            }
                            if (pC.useRandomRowid)
                            {
                                ///
                                ///<summary>
                                ///</summary>
                                ///<param name="IMPLEMENTATION">41881 If the largest ROWID is equal to the</param>
                                ///<param name="largest possible integer (9223372036854775807) then the database">largest possible integer (9223372036854775807) then the database</param>
                                ///<param name="engine starts picking positive candidate ROWIDs at random until">engine starts picking positive candidate ROWIDs at random until</param>
                                ///<param name="it finds one that is not previously used. ">it finds one that is not previously used. </param>
                                Debug.Assert(pOp.p3 == 0);
                                ///We cannot be in random rowid mode if vdbe is
                                ///an AUTOINCREMENT table. 
                                ///on the first attempt, simply do one more than previous 
                                v = cpu.lastRowid;
                                v &= (MAX_ROWID >> 1);
                                ///ensure doesn't go negative 
                                v++;
                                ///</summary>
                                ///<param name="ensure non">zero </param>
                                cnt = 0;
                                while (((rc = pC.pCursor.sqlite3BtreeMovetoUnpacked(null, v, 0, ref res)) == SqlResult.SQLITE_OK) && (res == 0) && (++cnt < 100))
                                {
                                    ///<param name="collision "> try another random rowid </param>
                                    Sqlite3.sqlite3_randomness(sizeof(i64), ref v);
                                    if (cnt < 5)
                                    {
                                        ///try "small" random rowids for the initial attempts 
                                        v &= 0xffffff;
                                    }
                                    else
                                    {
                                        v &= (MAX_ROWID >> 1);
                                        ///ensure doesn't go negative 
                                    }
                                    v++;
                                    ///</summary>
                                    ///<param name="ensure non">zero </param>
                                }
                                if (rc == SqlResult.SQLITE_OK && res == 0)
                                {
                                    rc = SqlResult.SQLITE_FULL;
                                    ///</summary>
                                    ///<param name="IMP: R">53002 </param>
                                    return RuntimeException.abort_due_to_error;
                                }
                                Debug.Assert(v > 0);
                                ///<param name="EV: R">03570 </param>
                            }
                            pC.rowidIsValid = false;
                            pC.deferredMoveto = false;
                            pC.cacheStatus = Sqlite3.CACHE_STALE;
                        }
                        cpu.pOut.u.i = (long)v;
                        break;
                    }
#endregion



                ///
                ///<summary>
                ///Opcode: RowData P1 P2 * * *
                ///
                ///Write into register P2 the complete row data for cursor P1.
                ///There is no interpretation of the data.
                ///It is just copied onto the P2 register exactly as
                ///it is found in the database file.
                ///
                ///If the P1 cursor must be pointing to a valid row (not a NULL row)
                ///</summary>
                ///<param name="of a real table, not a pseudo">table.</param>
                ///<param name=""></param>
                ///
                ///<summary>
                ///Opcode: RowKey P1 P2 * * *
                ///
                ///Write into register P2 the complete row key for cursor P1.
                ///There is no interpretation of the data.
                ///The key is copied onto the P3 register exactly as
                ///it is found in the database file.
                ///
                ///If the P1 cursor must be pointing to a valid row (not a NULL row)
                ///</summary>
                ///<param name="of a real table, not a pseudo">table.</param>
                ///<param name=""></param>
                case OpCode.OP_RowKey:
                case OpCode.OP_RowData:
                    {
                        VdbeCursor pC;
                        BtCursor pCrsr;
                        u32 n;
                        i64 n64;
                        n = 0;
                        n64 = 0;
                        cpu.pOut = aMem[pOp.p2];
                        vdbe.memAboutToChange(cpu.pOut);
                        ///
                        ///<summary>
                        ///Note that RowKey and RowData are really exactly the same instruction 
                        ///</summary>
                        Debug.Assert(pOp.p1 >= 0 && pOp.p1 < vdbe.nCursor);
                        pC = vdbe.OpenCursors[pOp.p1];
                        Debug.Assert(pC.isTable || pOp.OpCode == OpCode.OP_RowKey);
                        Debug.Assert(pC.isIndex || pOp.OpCode == OpCode.OP_RowData);
                        Debug.Assert(pC != null);
                        Debug.Assert(pC.nullRow == false);
                        Debug.Assert(pC.pseudoTableReg == 0);
                        Debug.Assert(pC.pCursor != null);
                        pCrsr = pC.pCursor;
                        Debug.Assert(pCrsr.sqlite3BtreeCursorIsValid());
                        ///
                        ///<summary>
                        ///The  OpCode.OP_RowKey and  OpCode.OP_RowData opcodes always follow  OpCode.OP_NotExists or
                        ///OP_Rewind/Op_Next with no intervening instructions that might invalidate
                        ///the cursor.  Hence the following sqlite3VdbeCursorMoveto() call is always
                        ///</summary>
                        ///<param name="a no">op and can never fail.  But we leave it in place as a safety.</param>
                        ///<param name=""></param>
                        Debug.Assert(pC.deferredMoveto == false);
                        rc = vdbeaux.sqlite3VdbeCursorMoveto(pC);
                        if (Sqlite3.NEVER(rc != SqlResult.SQLITE_OK))
                            return RuntimeException.abort_due_to_error;
                        if (pC.isIndex)
                        {
                            Debug.Assert(!pC.isTable);
                            rc = pCrsr.sqlite3BtreeKeySize(ref n64);
                            Debug.Assert(rc == SqlResult.SQLITE_OK);
                            ///
                            ///<summary>
                            ///True because of CursorMoveto() call above 
                            ///</summary>
                            if (n64 > db.aLimit[Globals.SQLITE_LIMIT_LENGTH])
                            {
                                return RuntimeException.too_big;
                            }
                            n = (u32)n64;
                        }
                        else
                        {
                            rc = pCrsr.sqlite3BtreeDataSize(ref n);
                            Debug.Assert(rc == SqlResult.SQLITE_OK);
                            ///
                            ///<summary>
                            ///DataSize() cannot fail 
                            ///</summary>
                            if (n > (u32)db.aLimit[Globals.SQLITE_LIMIT_LENGTH])
                            {
                                return RuntimeException.too_big;
                            }
                            if (cpu.pOut.Grow((int)n, 0) != 0)
                            {
                                return RuntimeException.no_mem;
                            }
                        }
                        cpu.pOut.n = (int)n;
                        if (pC.isIndex)
                        {
                            cpu.pOut.zBLOB = malloc_cs.sqlite3Malloc((int)n);
                            rc = pCrsr.sqlite3BtreeKey(0, n, cpu.pOut.zBLOB);
                        }
                        else
                        {
                            cpu.pOut.zBLOB = malloc_cs.sqlite3Malloc((int)pCrsr.info.nData);
                            rc = pCrsr.sqlite3BtreeData(0, (u32)n, cpu.pOut.zBLOB);
                        }

                        cpu.pOut.MemSetTypeFlag(MemFlags.MEM_Blob);
                        cpu.pOut.enc = SqliteEncoding.UTF8;
                        ///
                        ///<summary>
                        ///In case the blob is ever cast to text 
                        ///</summary>
#if SQLITE_TEST
																																																																																																																																				              UPDATE_MAX_BLOBSIZE( cpu.pOut );
#endif
                        break;
                    }
                ///
                ///<summary>
                ///Opcode: Rowid P1 P2 * * *
                ///
                ///Store in register P2 an integer which is the key of the table entry that
                ///P1 is currently point to.
                ///
                ///P1 can be either an ordinary table or a virtual table.  There used to
                ///be a separate  OpCode.OP_VRowid opcode for use with virtual tables, but vdbe
                ///one opcode now works for both table types.
                ///
                ///</summary>
                case OpCode.OP_Rowid:
                    {
                        ///
                        ///<summary>
                        ///</summary>
                        ///<param name="out2">prerelease </param>
                        VdbeCursor pC;
                        i64 v;
                        sqlite3_vtab pVtab;
                        sqlite3_module pModule;
                        v = 0;
                        Debug.Assert(pOp.p1 >= 0 && pOp.p1 < vdbe.nCursor);
                        pC = vdbe.OpenCursors[pOp.p1];
                        Debug.Assert(pC != null);
                        Debug.Assert(pC.pseudoTableReg == 0);
                        if (pC.nullRow)
                        {
                            cpu.pOut.flags = MemFlags.MEM_Null;
                            break;
                        }
                        else
                            if (pC.deferredMoveto)
                        {
                            v = pC.movetoTarget;
#if !SQLITE_OMIT_VIRTUALTABLE
                        }
                        else
                                if (pC.pVtabCursor != null)
                        {
                            pVtab = pC.pVtabCursor.pVtab;
                            pModule = pVtab.pModule;
                            Debug.Assert(pModule.xRowid != null);
                            rc = pModule.xRowid(pC.pVtabCursor, out v);
                            Sqlite3.importVtabErrMsg(vdbe, pVtab);
#endif
                        }
                        else
                        {
                            Debug.Assert(pC.pCursor != null);
                            rc = vdbeaux.sqlite3VdbeCursorMoveto(pC);
                            if (rc != 0)
                                return RuntimeException.abort_due_to_error;
                            if (pC.rowidIsValid)
                            {
                                v = pC.lastRowid;
                            }
                            else
                            {
                                rc = pC.pCursor.sqlite3BtreeKeySize(ref v);
                                Debug.Assert(rc == SqlResult.SQLITE_OK);
                                ///
                                ///<summary>
                                ///Always so because of CursorMoveto() above 
                                ///</summary>
                            }
                        }
                        cpu.pOut.u.i = (long)v;
                        break;
                    }





                                ///

                        //-------------------------------------------------------
                        ///<summary>
                        ///Opcode: RowSetTest P1 P2 P3 P4
                        ///
                        ///</summary>
                        ///<param name="Register P3 is assumed to hold a 64">bit integer value. If register P1</param>
                        ///<param name="contains a RowSet object and that RowSet object contains">contains a RowSet object and that RowSet object contains</param>
                        ///<param name="the value held in P3, jump to register P2. Otherwise, insert the">the value held in P3, jump to register P2. Otherwise, insert the</param>
                        ///<param name="integer in P3 into the RowSet and continue on to the">integer in P3 into the RowSet and continue on to the</param>
                        ///<param name="next opcode.">next opcode.</param>
                        ///<param name=""></param>
                        ///<param name="The RowSet object is optimized for the case where successive sets">The RowSet object is optimized for the case where successive sets</param>
                        ///<param name="of integers, where each set contains no duplicates. Each set">of integers, where each set contains no duplicates. Each set</param>
                        ///<param name="of values is identified by a unique P4 value. The first set">of values is identified by a unique P4 value. The first set</param>
                        ///<param name="must have P4==0, the final set P4=">1 or</param>
                        ///<param name="non">negative values of P4 only the lower 4</param>
                        ///<param name="bits are significant.">bits are significant.</param>
                        ///<param name=""></param>
                        ///<param name="vdbe allows optimizations: (a) when P4==0 there is no need to test">vdbe allows optimizations: (a) when P4==0 there is no need to test</param>
                        ///<param name="the rowset object for P3, as it is guaranteed not to contain it,">the rowset object for P3, as it is guaranteed not to contain it,</param>
                        ///<param name="(b) when P4==">1 there is no need to insert the value, as it will</param>
                        ///<param name="never be tested for, and (c) when a value that is part of set X is">never be tested for, and (c) when a value that is part of set X is</param>
                        ///<param name="inserted, there is no need to search to see if the same value was">inserted, there is no need to search to see if the same value was</param>
                        ///<param name="previously inserted as part of set X (only if it was previously">previously inserted as part of set X (only if it was previously</param>
                        ///<param name="inserted as part of some other set).">inserted as part of some other set).</param>
                        ///<param name=""></param>
                case OpCode.OP_RowSetTest:
                    {
                        ///
                        ///<summary>
                        ///jump, in1, in3 
                        ///</summary>
                        int iSet;
                        int exists;
                        pIn1 = aMem[pOp.p1];
                        pIn3 = aMem[pOp.p3];
                        iSet = pOp.p4.i;
                        Debug.Assert((pIn3.flags & MemFlags.MEM_Int) != 0);
                        ///
                        ///<summary>
                        ///If there is anything other than a rowset object in memory cell P1,
                        ///delete it now and initialize P1 with an empty rowset
                        ///
                        ///</summary>
                        if ((pIn1.flags & MemFlags.MEM_RowSet) == 0)
                        {
                            pIn1.sqlite3VdbeMemSetRowSet();
                            if ((pIn1.flags & MemFlags.MEM_RowSet) == 0)
                                return RuntimeException.no_mem;
                        }
                        Debug.Assert(pOp.p4type == P4Usage.P4_INT32);
                        Debug.Assert(iSet == -1 || iSet >= 0);
                        if (iSet != 0)
                        {
                            exists = pIn1.u.pRowSet.sqlite3RowSetTest((u8)(iSet >= 0 ? iSet & 0xf : 0xff), pIn3.u.i);
                            if (exists != 0)
                            {
                                cpu.opcodeIndex = pOp.p2 - 1;
                                break;
                            }
                        }
                        if (iSet >= 0)
                        {
                            pIn1.u.pRowSet.sqlite3RowSetInsert(pIn3.u.i);
                        }
                        break;
                    }
#if !SQLITE_OMIT_TRIGGER
                ///
                ///<summary>
                ///Opcode: Program P1 P2 P3 P4 *
                ///
                ///Execute the trigger program passed as P4 (type  P4Usage.P4_SUBPROGRAM). 
                ///
                ///P1 contains the address of the memory cell that contains the first memory 
                ///</summary>
                ///<param name="cell in an array of values used as arguments to the sub">program. P2 </param>
                ///<param name="contains the address to jump to if the sub">program throws an IGNORE </param>
                ///<param name="exception using the RAISE() function. Register P3 contains the address ">exception using the RAISE() function. Register P3 contains the address </param>
                ///<param name="of a memory cell in vdbe (the parent) VM that is used to allocate the ">of a memory cell in vdbe (the parent) VM that is used to allocate the </param>
                ///<param name="memory required by the sub">vdbe at runtime.</param>
                ///<param name=""></param>
                ///<param name="P4 is a pointer to the VM containing the trigger program.">P4 is a pointer to the VM containing the trigger program.</param>
                case OpCode.OP_Program:
                    {
                        ///jump 
                        int nMem;
                        ///<param name="Number of memory registers for sub">program </param>
                        int nByte;
                        ///<param name="Bytes of runtime space required for sub">program </param>
                        Mem pRt;
                        ///Register to allocate runtime space 
                        Mem pMem = null;
                        ///Used to iterate through memory cells 
                        //Mem pEnd;            /* Last memory cell in new array */
                        VdbeFrame pFrame;
                        ///New vdbe frame to execute in 
                        SubProgram pProgram;
                        ///<param name="Sub">program to execute </param>
                        int t;
                        ///Token identifying trigger 
                        pProgram = pOp.p4.pProgram;
                        pRt = aMem[pOp.p3];
                        Debug.Assert(pRt.memIsValid());
                        Debug.Assert(pProgram.nOp > 0);
                        ///If the p5 flag is clear, then recursive invocation of triggers is 
                        ///</summary>
                        ///<param name="disabled for backwards compatibility (p5 is set if vdbe sub">program</param>
                        ///<param name="is really a trigger, not a foreign key action, and the flag set">is really a trigger, not a foreign key action, and the flag set</param>
                        ///<param name="and cleared by the "PRAGMA recursive_triggers" command is clear).">and cleared by the "PRAGMA recursive_triggers" command is clear).</param>
                        ///<param name=""></param>
                        ///<param name="It is recursive invocation of triggers, at the SQL level, that is ">It is recursive invocation of triggers, at the SQL level, that is </param>
                        ///<param name="disabled. In some cases a single trigger may generate more than one ">disabled. In some cases a single trigger may generate more than one </param>
                        ///<param name="SubProgram (if the trigger may be executed with more than one different ">SubProgram (if the trigger may be executed with more than one different </param>
                        ///<param name="ON CONFLICT algorithm). SubProgram structures associated with a">ON CONFLICT algorithm). SubProgram structures associated with a</param>
                        ///<param name="single trigger all have the same value for the SubProgram.token ">single trigger all have the same value for the SubProgram.token </param>
                        ///<param name="variable.  ">variable.  </param>
                        if (pOp.p5 != 0)
                        {
                            t = pProgram.token;
                            for (pFrame = vdbe.pFrame; pFrame != null && pFrame.token != t; pFrame = pFrame.pParent)
                                ;
                            if (pFrame != null)
                                break;
                        }
                        if (vdbe.nFrame >= db.aLimit[Globals.SQLITE_LIMIT_TRIGGER_DEPTH])
                        {
                            rc = SqlResult.SQLITE_ERROR;
                            malloc_cs.sqlite3SetString(ref vdbe.zErrMsg, db, "too many levels of trigger recursion");
                            break;
                        }
                        ///
                        ///<summary>
                        ///Register pRt is used to store the memory required to save the state
                        ///of the current program, and the memory required at runtime to execute
                        ///the trigger program. If vdbe trigger has been fired before, then pRt 
                        ///is already allocated. Otherwise, it must be initialized.  
                        ///</summary>
                        if ((pRt.flags & MemFlags.MEM_Frame) == 0)
                        {
                            ///
                            ///<summary>
                            ///SubProgram.nMem is set to the number of memory cells used by the 
                            ///program stored in SubProgram.aOp. As well as these, one memory
                            ///cell is required for each cursor used by the program. Set local
                            ///variable nMem (and later, VdbeFrame.nChildMem) to vdbe value.
                            ///
                            ///</summary>
                            nMem = pProgram.nMem + pProgram.nCsr;
                            //nByte = ROUND8( sizeof( VdbeFrame ) )
                            //+ nMem * sizeof( Mem )
                            //+ pProgram.nCsr * sizeof( VdbeCursor* );
                            pFrame = new VdbeFrame();
                            // sqlite3DbMallocZero( db, nByte );
                            //if ( !pFrame )
                            //{
                            //  return RuntimeException.no_mem;
                            //}
                            pRt.sqlite3VdbeMemRelease();
                            pRt.flags = MemFlags.MEM_Frame;
                            pRt.u.pFrame = pFrame;
                            pFrame.v = vdbe;
                            pFrame.nChildMem = nMem;
                            pFrame.nChildCsr = pProgram.nCsr;
                            pFrame.currentOpCodeIndex = cpu.opcodeIndex;
                            pFrame.aMem = vdbe.aMem;
                            pFrame.nMem = vdbe.nMem;
                            pFrame.apCsr = vdbe.OpenCursors;
                            pFrame.nCursor = vdbe.nCursor;
                            pFrame.aOp = vdbe.aOp;
                            pFrame.nOp = vdbe.nOp;
                            pFrame.token = pProgram.token;
                            // &VdbeFrameMem( pFrame )[pFrame.nChildMem];
                            // aMem is 1 based, so allocate 1 extra cell under C#
                            pFrame.aChildMem = new Mem[pFrame.nChildMem + 1];
                            for (int i = 0; i < pFrame.aChildMem.Length; i++)//pMem = VdbeFrameMem( pFrame ) ; pMem != pEnd ; pMem++ )
                            {
                                //pFrame.aMem[i] = pFrame.aMem[pFrame.nMem+i];
                                pMem = malloc_cs.sqlite3Malloc(pMem);
                                pMem.flags = MemFlags.MEM_Null;
                                pMem.db = db;
                                pFrame.aChildMem[i] = pMem;
                            }
                            pFrame.aChildCsr = new VdbeCursor[pFrame.nChildCsr];
                            for (int i = 0; i < pFrame.nChildCsr; i++)
                                pFrame.aChildCsr[i] = new VdbeCursor();
                        }
                        else
                        {
                            pFrame = pRt.u.pFrame;
                            Debug.Assert(pProgram.nMem + pProgram.nCsr == pFrame.nChildMem);
                            Debug.Assert(pProgram.nCsr == pFrame.nChildCsr);
                            Debug.Assert(cpu.opcodeIndex == pFrame.currentOpCodeIndex);
                        }
                        vdbe.nFrame++;
                        pFrame.pParent = vdbe.pFrame;
                        pFrame.lastRowid = cpu.lastRowid;
                        pFrame.nChange = vdbe.nChange;
                        vdbe.nChange = 0;
                        vdbe.pFrame = pFrame;
                        vdbe.aMem = aMem = pFrame.aChildMem;
                        // &VdbeFrameMem( pFrame )[-1];
                        vdbe.nMem = pFrame.nChildMem;
                        vdbe.nCursor = (u16)pFrame.nChildCsr;
                        vdbe.OpenCursors = pFrame.aChildCsr;
                        // (VdbeCursor *)&aMem[p->nMem+1];
                        vdbe.lOp = lOp = new List<Operation>(pProgram.aOp);
                        vdbe.nOp = pProgram.nOp;
                        cpu.opcodeIndex = -1;
                        break;
                    }
                ///
                ///<summary>
                ///Opcode: Param P1 P2 * * *
                ///
                ///</summary>
                ///<param name="vdbe opcode is only ever present in sub">programs called via the </param>
                ///<param name="OP_Program instruction. Copy a value currently stored in a memory ">OP_Program instruction. Copy a value currently stored in a memory </param>
                ///<param name="cell of the calling (parent) frame to cell P2 in the current frames ">cell of the calling (parent) frame to cell P2 in the current frames </param>
                ///<param name="address space. vdbe is used by trigger programs to access the new.* ">address space. vdbe is used by trigger programs to access the new.* </param>
                ///<param name="and old.* values.">and old.* values.</param>
                ///<param name=""></param>
                ///<param name="The address of the cell in the parent frame is determined by adding">The address of the cell in the parent frame is determined by adding</param>
                ///<param name="the value of the P1 argument to the value of the P1 argument to the">the value of the P1 argument to the value of the P1 argument to the</param>
                ///<param name="calling  OpCode.OP_Program instruction.">calling  OpCode.OP_Program instruction.</param>
                ///<param name=""></param>
                case OpCode.OP_Param:
                    {
                        ///
                        ///<summary>
                        ///</summary>
                        ///<param name="out2">prerelease </param>
                        VdbeFrame pFrame;
                        Mem pIn;
                        pFrame = vdbe.pFrame;
                        pIn = pFrame.aMem[pOp.p1 + pFrame.aOp[pFrame.currentOpCodeIndex].p1];
                        vdbemem_cs.sqlite3VdbeMemShallowCopy(cpu.pOut, pIn, MemFlags.MEM_Ephem);
                        break;
                    }
#endif
#if !SQLITE_OMIT_FOREIGN_KEY
                ///
                ///<summary>
                ///Opcode: FkCounter P1 P2 * * *
                ///
                ///Increment a "constraint counter" by P2 (P2 may be negative or positive).
                ///</summary>
                ///<param name="If P1 is non">zero, the database constraint counter is incremented </param>
                ///<param name="(deferred foreign key constraints). Otherwise, if P1 is zero, the ">(deferred foreign key constraints). Otherwise, if P1 is zero, the </param>
                ///<param name="statement counter is incremented (immediate foreign key constraints).">statement counter is incremented (immediate foreign key constraints).</param>
                case OpCode.OP_FkCounter:
                    {
                        if (pOp.p1 != 0)
                        {
                            db.nDeferredCons += pOp.p2;
                        }
                        else
                        {
                            vdbe.nFkConstraint += pOp.p2;
                        }
                        break;
                    }
                ///
                ///<summary>
                ///Opcode: FkIfZero P1 P2 * * *
                ///
                ///</summary>
                ///<param name="vdbe opcode tests if a foreign key constraint">counter is currently zero.</param>
                ///<param name="If so, jump to instruction P2. Otherwise, fall through to the next ">If so, jump to instruction P2. Otherwise, fall through to the next </param>
                ///<param name="instruction.">instruction.</param>
                ///<param name=""></param>
                ///<param name="If P1 is non">counter</param>
                ///<param name="is zero (the one that counts deferred constraint violations). If P1 is">is zero (the one that counts deferred constraint violations). If P1 is</param>
                ///<param name="zero, the jump is taken if the statement constraint">counter is zero</param>
                ///<param name="(immediate foreign key constraint violations).">(immediate foreign key constraint violations).</param>
                ///<param name=""></param>
                case OpCode.OP_FkIfZero:
                    {
                        ///
                        ///<summary>
                        ///jump 
                        ///</summary>
                        if (pOp.p1 != 0)
                        {
                            if (db.nDeferredCons == 0)
                                cpu.opcodeIndex = pOp.p2 - 1;
                        }
                        else
                        {
                            if (vdbe.nFkConstraint == 0)
                                cpu.opcodeIndex = pOp.p2 - 1;
                        }
                        break;
                    }
#endif
#if !SQLITE_OMIT_AUTOINCREMENT
                ///
                ///<summary>
                ///Opcode: MemMax P1 P2 * * *
                ///
                ///P1 is a register in the root frame of vdbe VM (the root frame is
                ///different from the current frame if vdbe instruction is being executed
                ///</summary>
                ///<param name="within a sub">program). Set the value of register P1 to the maximum of </param>
                ///<param name="its current value and the value in register P2.">its current value and the value in register P2.</param>
                ///<param name=""></param>
                ///<param name="vdbe instruction throws an error if the memory cell is not initially">vdbe instruction throws an error if the memory cell is not initially</param>
                ///<param name="an integer.">an integer.</param>
                case OpCode.OP_MemMax:
                    {
                        ///
                        ///<summary>
                        ///in2 
                        ///</summary>
                        Mem _pIn1;
                        VdbeFrame pFrame;
                        if (vdbe.pFrame != null)
                        {
                            for (pFrame = vdbe.pFrame; pFrame.pParent != null; pFrame = pFrame.pParent)
                                ;
                            _pIn1 = pFrame.aMem[pOp.p1];
                        }
                        else
                        {
                            _pIn1 = aMem[pOp.p1];
                        }
                        Debug.Assert(_pIn1.memIsValid());
                        _pIn1.sqlite3VdbeMemIntegerify();
                        pIn2 = aMem[pOp.p2];
                        pIn2.sqlite3VdbeMemIntegerify();
                        if (_pIn1.u.i < pIn2.u.i)
                        {
                            _pIn1.u.i = pIn2.u.i;
                        }
                        break;
                    }
#endif

                ///Opcode: AggStep * P2 P3 P4 P5
                ///
                ///Execute the step function for an aggregate.  The
                ///function has P5 arguments.   P4 is a pointer to the FuncDef
                ///structure that specifies the function.  Use register
                ///P3 as the accumulator.
                ///
                ///The P5 arguments are taken from register P2 and its
                ///successors.
                ///
                ///</summary>
                case OpCode.OP_AggStep:
                    {
                        int n;
                        int i;
                        Mem pMem;
                        Mem pRec;
                        sqlite3_context ctx = new sqlite3_context();
                        sqlite3_value[] apVal;
                        n = pOp.p5;
                        Debug.Assert(n >= 0);
                        //pRec = aMem[pOp.p2];
                        apVal = vdbe.apArg;
                        Debug.Assert(apVal != null || n == 0);
                        for (i = 0; i < n; i++)//, pRec++)
                        {
                            pRec = aMem[pOp.p2 + i];
                            Debug.Assert(pRec.memIsValid());
                            apVal[i] = pRec;
                            vdbe.memAboutToChange(pRec);
                            Sqlite3.sqlite3VdbeMemStoreType(pRec);
                        }
                        ctx.pFunc = pOp.p4.pFunc;
                        Debug.Assert(pOp.p3 > 0 && pOp.p3 <= vdbe.nMem);
                        ctx.pMem = pMem = aMem[pOp.p3];
                        pMem.n++;
                        ctx.s.flags = MemFlags.MEM_Null;
                        ctx.s.z = null;
                        //ctx.s.zMalloc = null;
                        ctx.s.xDel = null;
                        ctx.s.db = db;
                        ctx.isError = 0;
                        ctx.pColl = null;
                        if ((ctx.pFunc.flags & FuncFlags.SQLITE_FUNC_NEEDCOLL) != 0)
                        {
                            Debug.Assert(cpu.opcodeIndex > 0);
                            //pOp > p.aOp );
                            Debug.Assert(vdbe.lOp[cpu.opcodeIndex - 1].p4type == P4Usage.P4_COLLSEQ);
                            //pOp[-1].p4type ==  P4Usage.P4_COLLSEQ );
                            Debug.Assert(vdbe.lOp[cpu.opcodeIndex - 1].OpCode == OpCode.OP_CollSeq);
                            // pOp[-1].opcode ==  OpCode.OP_CollSeq );
                            ctx.pColl = vdbe.lOp[cpu.opcodeIndex - 1].p4.pColl;
                            ;
                            // pOp[-1].p4.pColl;
                        }
                        ctx.pFunc.xStep(ctx, n, apVal);
                        ///
                        ///<summary>
                        ///</summary>
                        ///<param name="IMP: R">23230 </param>
                        if (ctx.isError != 0)
                        {
                            malloc_cs.sqlite3SetString(ref vdbe.zErrMsg, db, vdbeapi.sqlite3_value_text(ctx.s));
                            rc = ctx.isError;
                        }
                        ctx.s.sqlite3VdbeMemRelease();
                        break;
                    }
                ///
                ///<summary>
                ///Opcode: AggFinal P1 P2 * P4 *
                ///
                ///Execute the finalizer function for an aggregate.  P1 is
                ///the memory location that is the accumulator for the aggregate.
                ///
                ///P2 is the number of arguments that the step function takes and
                ///P4 is a pointer to the FuncDef for vdbe function.  The P2
                ///argument is not used by vdbe opcode.  It is only there to disambiguate
                ///functions that can take varying numbers of arguments.  The
                ///P4 argument is only needed for the degenerate case where
                ///the step function was not previously called.
                ///
                ///</summary>
                case OpCode.OP_AggFinal:
                    {
                        Mem pMem;
                        Debug.Assert(pOp.p1 > 0 && pOp.p1 <= vdbe.nMem);
                        pMem = aMem[pOp.p1];
                        Debug.Assert((pMem.flags & ~(MemFlags.MEM_Null | MemFlags.MEM_Agg)) == 0);
                        rc = vdbemem_cs.sqlite3VdbeMemFinalize(pMem, pOp.p4.pFunc);
                        vdbe.aMem[pOp.p1] = pMem;
                        if (rc != 0)
                        {
                            malloc_cs.sqlite3SetString(ref vdbe.zErrMsg, db, vdbeapi.sqlite3_value_text(pMem));
                        }
                        vdbemem_cs.sqlite3VdbeChangeEncoding(pMem, encoding);
#if SQLITE_TEST
																																																																																																																																				              UPDATE_MAX_BLOBSIZE( pMem );
#endif
                        if (pMem.IsTooBig())
                        {
                            return RuntimeException.too_big;
                        }
                        break;
                    }
#if !SQLITE_OMIT_WAL
																																																																																																											/* Opcode: Checkpoint P1 P2 P3 * *
**
** Checkpoint database P1. vdbe is a no-op if P1 is not currently in
** WAL mode. Parameter P2 is one of SQLITE_CHECKPOINT_PASSIVE, FULL
** or RESTART.  Write 1 or 0 into mem[P3] if the checkpoint returns
** SQLITE_BUSY or not, respectively.  Write the number of pages in the
** WAL after the checkpoint into mem[P3+1] and the number of pages
** in the WAL that have been checkpointed after the checkpoint
** completes into mem[P3+2].  However on an error, mem[P3+1] and
** mem[P3+2] are initialized to -1.
*/
cDebug.Ase  OpCode.OP_Checkpoint: {
  aRes[0] = 0;
  aRes[1] = aRes[2] = -1;
  Debug.Assert( pOp.p2==SQLITE_CHECKPOINT_PDebug.AsSIVE
       || pOp.p2==SQLITE_CHECKPOINT_FULL
       || pOp.p2==SQLITE_CHECKPOINT_RESTART
  );
  rc = sqlite3Checkpoint(db, pOp.p1, pOp.p2, ref aRes[1], ref aRes[2]);
  if( rc==SQLITE_BUSY ){
    rc = SqlResult.SQLITE_OK;
    aRes[0] = 1;
  }
  for(i=0, pMem = aMem[pOp.p3]; i<3; i++, pMem++){
    sqlite3VdbeMemSetInt64(pMem, (i64)aRes[i]);
  }
  break;
};  
#endif
#if !SQLITE_OMIT_PRAGMA
                ///
                ///<summary>
                ///Opcode: JournalMode P1 P2 P3 * P5
                ///
                ///Change the journal mode of database P1 to P3. P3 must be one of the
                ///PAGER_JOURNALMODE_XXX values. If changing between the various rollback
                ///modes (delete, truncate, persist, off and memory), vdbe is a simple
                ///operation. No IO is required.
                ///
                ///If changing into or out of WAL mode the procedure is more complicated.
                ///
                ///</summary>
                ///<param name="Write a string containing the final journal">mode to register P2.</param>
                case OpCode.OP_JournalMode:
                    {
                        ///<param name="out2">prerelease </param>
                        Btree pBt;
                        ///Btree to change journal mode of 
                        Pager pPager;
                        ///Pager associated with pBt 
                        JournalMode eNew;
                        ///New journal mode 
                        JournalMode eOld;
                        ///The old journal mode 
                        string zFilename;
                        ///Name of database file for pPager 
                        eNew = (JournalMode)pOp.p3;
                        Debug.Assert(eNew == JournalMode.PAGER_JOURNALMODE_DELETE || eNew == JournalMode.PAGER_JOURNALMODE_TRUNCATE || eNew == JournalMode.PAGER_JOURNALMODE_PERSIST || eNew == JournalMode.PAGER_JOURNALMODE_OFF || eNew == JournalMode.PAGER_JOURNALMODE_MEMORY || eNew == JournalMode.PAGER_JOURNALMODE_WAL || eNew == JournalMode.PAGER_JOURNALMODE_QUERY);
                        Debug.Assert(pOp.p1 >= 0 && pOp.p1 < db.BackendCount);
                        pBt = db.Backends[pOp.p1].BTree;
                        pPager = pBt.sqlite3BtreePager();
                        eOld = pPager.sqlite3PagerGetJournalMode();
                        if (eNew == JournalMode.PAGER_JOURNALMODE_QUERY)
                            eNew = eOld;
                        if (0 == pPager.sqlite3PagerOkToChangeJournalMode())
                            eNew = eOld;
#if !SQLITE_OMIT_WAL
																																																																																																																																					zFilename = sqlite3PagerFilename(pPager);

/* Do not allow a transition to journal_mode=WAL for a database
** in temporary storage or if the VFS does not support shared memory 
*/
if( eNew==PAGER_JOURNALMODE_WAL
&& (zFilename[0]==0                         /* Temp file */
|| !sqlite3PagerWalSupported(pPager))   /* No shared-memory support */
){
eNew = eOld;
}

if( (eNew!=eOld)
&& (eOld==PAGER_JOURNALMODE_WAL || eNew==PAGER_JOURNALMODE_WAL)
){
if( null==db.autoCommit || db.activeVdbeCnt>1 ){
rc = SqlResult.SQLITE_ERROR;
malloc_cs.sqlite3SetString(&p.zErrMsg, db, 
"cannot change %s wal mode from within a transaction",
(eNew==PAGER_JOURNALMODE_WAL ? "into" : "out of")
);
break;
}else{

if( eOld==PAGER_JOURNALMODE_WAL ){
/* If leaving WAL mode, close the log file. If successful, the call
** to PagerCloseWal() checkpoints and deletes the write-ahead-log 
** file. An EXCLUSIVE lock may still be held on the database file 
** after a successful return. 
*/
rc = sqlite3PagerCloseWal(pPager);
if( rc==SqlResult.SQLITE_OK ){
sqlite3PagerSetJournalMode(pPager, eNew);
}
}else if( eOld==PAGER_JOURNALMODE_MEMORY ){
/* Cannot transition directly from MEMORY to WAL.  Use mode OFF
** as an intermediate */
sqlite3PagerSetJournalMode(pPager, PAGER_JOURNALMODE_OFF);
}

/* Open a transaction on the database file. Regardless of the journal
** mode, vdbe transaction always uses a rollback journal.
*/
Debug.Assert( sqlite3BtreeIsInTrans(pBt)==0 );
if( rc==SqlResult.SQLITE_OK ){
rc = sqlite3BtreeSetVersion(pBt, (eNew==PAGER_JOURNALMODE_WAL ? 2 : 1));
}
}
}
#endif
                        if (rc != 0)
                        {
                            eNew = eOld;
                        }
                        eNew = pPager.sqlite3PagerSetJournalMode(eNew);
                        cpu.pOut = aMem[pOp.p2];
                        cpu.pOut.flags = MemFlags.MEM_Str | MemFlags.MEM_Static | MemFlags.MEM_Term;
                        cpu.pOut.z = Sqlite3.sqlite3JournalModename(eNew);
                        cpu.pOut.n = StringExtensions.Strlen30(cpu.pOut.z);
                        cpu.pOut.enc = SqliteEncoding.UTF8;
                        vdbemem_cs.sqlite3VdbeChangeEncoding(cpu.pOut, encoding);
                        break;
                    }
                                    ;
#endif

                ///
                ///<summary>
                ///Opcode: Expire P1 * * * *
                ///
                ///Cause precompiled statements to become expired. An expired statement
                ///fails with an error code of SQLITE_SCHEMA if it is ever executed
                ///(via sqlite3_step()).
                ///
                ///</summary>
                ///<param name="If P1 is 0, then all SQL statements become expired. If P1 is non">zero,</param>
                ///<param name="then only the currently executing statement is affected.">then only the currently executing statement is affected.</param>
                case OpCode.OP_Expire:
                    {
                        if (pOp.p1 == 0)
                        {
                            vdbeaux.sqlite3ExpirePreparedStatements(db);
                        }
                        else
                        {
                            vdbe.expired = true;
                        }
                        break;
                    }
#if !SQLITE_OMIT_SHARED_CACHE
																																																																																																											/* Opcode: TableLock P1 P2 P3 P4 *
**
** Obtain a lock on a particular table. vdbe instruction is only used when
** the shared-cache feature is enabled.
**
** P1 is the index of the database in sqlite3.aDb[] of the database
** on which the lock is acquired.  A readlock is obtained if P3==0 or
** a write lock if P3==1.
**
** P2 contains the root-page of the table to lock.
**
** P4 contains a pointer to the name of the table being locked. vdbe is only
** used to generate an error message if the lock cannot be obtained.
*/
case  OpCode.OP_TableLock:
{
u8 isWriteLock = (u8)pOp.p3;
if( isWriteLock || 0==(db.flags&SQLITE_ReadUncommitted) ){
int p1 = pOp.p1; 
Debug.Assert( p1 >= 0 && p1 < db.nDb );
Debug.Assert( ( p.btreeMask & ( ((yDbMask)1) << p1 ) ) != 0 );
Debug.Assert( isWriteLock == 0 || isWriteLock == 1 );
rc = sqlite3BtreeLockTable( db.aDb[p1].pBt, pOp.p2, isWriteLock );
if ( ( rc & 0xFF ) == SQLITE_LOCKED )
{
string z = pOp.p4.z;
malloc_cs.sqlite3SetString( ref p.zErrMsg, db, "database table is locked: ", z );
}
}
break;
}
#endif



                default: return RuntimeException.noop;



            }
            return RuntimeException.OK;
        }


        enum ColumnResult
        {
            abort_due_to_error,
            op_column_out,
            too_big

        }
        private static SqlResult OpCode_Column(Vdbe vdbe, Operation pOp, SqlResult rc, Connection db, SqliteEncoding encoding, Mem[] aMem)
        {
            ///The length of the serialized data for the column 
            int len;
            ///Number of bytes in the record 
            u32 payloadSize = 0;
            ///Pointer to complete record
            byte[] zRecord = null;
            ///Number of bytes in the record : INDEX 
            i64 payloadSize64 = 0;

            ///P1 value of the opcode 
            ///
            int p1 = pOp.p1;
            Debug.Assert(p1 < vdbe.nCursor);

            ///column number to retrieve 
            int clumnNumber_p2 = pOp.p2;
            ///The VDBE cursor 
            VdbeCursor vdbeCursor = vdbe.OpenCursors[p1];
            ///vdbe block sets the variable payloadSize to be the total number of
            ///bytes in the record.
            ///
            ///zRec is set to be the complete text of the record if it is available.
            ///The complete record text is always available for pseudo">tables</param>
            ///If the record is stored in a cursor, the complete record text
            ///might be available in the  pC.aRow cache.  Or it might not be.
            ///If the data is unavailable,  zRec is set to NULL.">If the data is unavailable,  zRec is set to NULL.</param>
            ///We also compute the number of columns in the record.  For cursors,
            ///the number of columns is stored in the VdbeCursor.nField element.

            ///number of fields in the record 
            int nField = vdbeCursor.nField;

            ///The BTree cursor 
            BtCursor btCursor = vdbeCursor.pCursor;
            ///aType[i] holds the numeric type of the i"th column 
            u32[] columnTypes = vdbeCursor.aType;


            ///Loop counter 
            int i;
            ///Part of the record being decoded 
            byte[] zData = null;
            ///Where to write the extracted value 
            Debug.Assert(pOp.p3 > 0 && pOp.p3 <= vdbe.nMem);
            Mem pDest = aMem[pOp.p3];
            ///For storing the record being decoded 
            Mem sMem = null;
            sMem = malloc_cs.sqlite3Malloc(sMem);


            ///Index into header 
            int idxHeader;
            ///Pointer to first byte after the header 
            int idxEndHeader;
            ///Offset into the data 
            u32 offsetIntoData = 0;
            ///Number of bytes in the content of a field 
            u32 szField = 0;

            ///Number of bytes of available data 
            int avail;
            ///PseudoTable input register 
            Mem pReg;


            //  memset(&sMem, 0, sizeof(sMem));

            vdbe.memAboutToChange(pDest);
            pDest.MemSetTypeFlag(MemFlags.MEM_Null);

            Debug.Assert(vdbeCursor != null);
#if !SQLITE_OMIT_VIRTUALTABLE
            Debug.Assert(vdbeCursor.pVtabCursor == null);
#endif

            #region payload size
            if (btCursor != null)
            {
                ///The record is stored in a B">Tree
                rc = vdbeaux.sqlite3VdbeCursorMoveto(vdbeCursor);
                if (rc != 0)
                    return (int)ColumnResult.abort_due_to_error;
                //goto  abort_due_to_error;
                if (vdbeCursor.nullRow)
                {
                    payloadSize = 0;
                }
                else
                {
                    if ((vdbeCursor.cacheStatus == vdbe.cacheCtr) && (vdbeCursor.aRow != -1))
                    {
                        payloadSize = vdbeCursor.payloadSize;
                        zRecord = malloc_cs.sqlite3Malloc((int)payloadSize);
                        Buffer.BlockCopy(btCursor.info.pCell, vdbeCursor.aRow, zRecord, 0, (int)payloadSize);
                    }
                    else
                    {
                        if (vdbeCursor.isIndex)
                        {
                            Debug.Assert(btCursor.sqlite3BtreeCursorIsValid());
                            rc = btCursor.sqlite3BtreeKeySize(ref payloadSize64);
                            Debug.Assert(rc == SqlResult.SQLITE_OK);
                            ///True because of CursorMoveto() call above 
                            ///sqlite3BtreeParseCellPtr() uses utilc.getVarint32() to extract the
                            ///payload size, so it is impossible for payloadSize64 to be
                            ///larger than 32 bits. 
                            Debug.Assert(((u64)payloadSize64 & sqliteinth.SQLITE_MAX_U32) == (u64)payloadSize64);
                            payloadSize = (u32)payloadSize64;
                        }
                        else
                        {
                            Debug.Assert(btCursor.sqlite3BtreeCursorIsValid());
                            rc = btCursor.sqlite3BtreeDataSize(ref payloadSize);
                            Debug.Assert(rc == SqlResult.SQLITE_OK);
                            ///
                            ///<summary>
                            ///DataSize() cannot fail 
                            ///</summary>
                        }
                    }
                }
            }
            else
            {
                if (vdbeCursor.pseudoTableReg > 0)
                {
                    ///The record is the sole entry of a pseudo">table
                    pReg = aMem[vdbeCursor.pseudoTableReg];
                    Debug.Assert((pReg.flags & MemFlags.MEM_Blob) != 0);
                    Debug.Assert(pReg.memIsValid());
                    payloadSize = (u32)pReg.n;
                    zRecord = pReg.zBLOB;
                    vdbeCursor.cacheStatus = ((OpFlag)pOp.p5 & OpFlag.OPFLAG_CLEARCACHE) != 0 ? Sqlite3.CACHE_STALE : vdbe.cacheCtr;
                    Debug.Assert(payloadSize == 0 || zRecord != null);
                }
                else
                {
                    ///Consider the row to be NULL 
                    payloadSize = 0;
                }
            }

            #endregion

            ///If payloadSize is 0, then just store a NULL 
            if (payloadSize == 0)
            {
                Debug.Assert((pDest.flags & MemFlags.MEM_Null) != 0);
                return (SqlResult)ColumnResult.op_column_out;
            }
            Debug.Assert(db.aLimit[Globals.SQLITE_LIMIT_LENGTH] >= 0);
            if (payloadSize > (u32)db.aLimit[Globals.SQLITE_LIMIT_LENGTH])
            {
                return (SqlResult)ColumnResult.too_big;
            }


            Debug.Assert(clumnNumber_p2 < nField);

            //aOffset[i] is offset to start of data for i">th column
            u32[] clumnOffsets;

            ///Read and parse the table header.  Store the results of the parse
            ///into the record header cache fields of the cursor.

            if (vdbeCursor.cacheStatus == vdbe.cacheCtr)
            {
                clumnOffsets = vdbeCursor.aOffset;
            }
            else
            {
                Debug.Assert(columnTypes != null);
                avail = 0;
                //pC.aOffset = aOffset = aType[nField];
                clumnOffsets = new u32[nField];
                vdbeCursor.aOffset = clumnOffsets;
                vdbeCursor.payloadSize = payloadSize;
                vdbeCursor.cacheStatus = vdbe.cacheCtr;
                ///Figure out how many bytes are in the header 
                if (zRecord != null)
                {
                    zData = zRecord;
                }
                else
                {
                    if (vdbeCursor.isIndex)
                    {
                        zData = btCursor.KeyFetch(ref avail, ref vdbeCursor.aRow);
                    }
                    else
                    {
                        zData = btCursor.DataFetch(ref avail, ref vdbeCursor.aRow);
                    }
                    ///If KeyFetch()/DataFetch() managed to get the entire payload,
                    ///save the payload in the pC.aRow cache.  That will save us from
                    ///having to make additional calls to fetch the content portion of
                    ///the record.
                    Debug.Assert(avail >= 0);
                    if (payloadSize <= (u32)avail)
                    {
                        zRecord = zData;
                        //vdbeCursor.aRow = zData;
                    }
                    else
                    {
                        vdbeCursor.aRow = -1;
                        //pC.aRow = null;
                    }
                }
                ///The following Debug.Assert is true in all cases accept when
                ///the database file has been corrupted externally.
                ///Debug.Assert( zRec!=0 || avail>=payloadSize || avail>=9 );
                ///
                ///Size of the header size field at start of record 
                int szHdr;
                szHdr = utilc.getVarint32(zData, out offsetIntoData);
                ///Make sure a corrupt database has not given us an oversize header.
                ///Do vdbe now to avoid an oversize memory allocation.
                ///
                ///Type entries can be between 1 and 5 bytes each.  But 4 and 5 byte
                ///types use so much data space that there can only be 4096 and 32 of
                ///them, respectively.  So the maximum header length results from a
                ///3">byte type for each of the maximum of 32768 columns plus three</param>
                ///extra bytes for the header length itself.  32768*3 + 3 = 98307.">extra bytes for the header length itself.  32768*3 + 3 = 98307.</param>
                ///"></param>
                if (offsetIntoData > 98307)
                {
                    rc = sqliteinth.SQLITE_CORRUPT_BKPT();
                    return (SqlResult)ColumnResult.op_column_out;
                }
                ///Compute in len the number of bytes of data we need to read in order
                ///to get nField type values.  offset is an upper bound on vdbe.  But
                ///nField might be significantly less than the true number of columns
                ///in the table, and in that case, 5*nField+3 might be smaller than offset.
                ///We want to minimize len in order to limit the size of the memory
                ///allocation, especially if a corrupt database file has caused offset
                ///to be oversized. Offset is limited to 98307 above.  But 98307 might
                ///still exceed Robson memory allocation limits on some configurations.
                ///On systems that cannot tolerate large memory allocations, nField*5+3
                ///will likely be much smaller since nField will likely be less than
                ///20 or so.  vdbe insures that Robson memory allocation limits are
                ///not exceeded even for corrupt database files.
                len = nField * 5 + 3;
                if (len > (int)offsetIntoData)
                    len = (int)offsetIntoData;
                ///The KeyFetch() or DataFetch() above are fast and will get the entire
                ///record header in most cases.  But they will fail to get the complete
                ///record header if the record header does not fit on a single page
                ///in the B"Tree.  When that happens, use sqlite3VdbeMemFromBtree() to
                ///acquire the complete header text.
                if (zRecord == null && avail < len)
                {
                    sMem.db = null;
                    sMem.flags = 0;
                    rc = vdbemem_cs.sqlite3VdbeMemFromBtree(btCursor, 0, len, vdbeCursor.isIndex, sMem);
                    if (rc != SqlResult.SQLITE_OK)
                    {
                        return (SqlResult)ColumnResult.op_column_out;
                    }
                    zData = sMem.zBLOB;
                }
                idxEndHeader = len;
                // zData[len];
                idxHeader = szHdr;
                // zData[szHdr];
                ///
                ///Scan the header and use it to fill in the aType[] and aOffset[]
                ///arrays.  aType[i] will contain the type integer for the i'th
                ///column and aOffset[i] will contain the offset from the beginning
                ///of the record to the start of the data for the i"th column
                ///
                ///Tural: zData 
                ///[0]          : number of columns
                ///[1-num]      : type of the column
                ///[num,2*num]  : data of the column
                for (i = 0; i < nField; i++)
                {
                    if (idxHeader < idxEndHeader)
                    {
                        clumnOffsets[i] = offsetIntoData;
                        idxHeader += utilc.getVarint32(zData, idxHeader, out columnTypes[i]);
                        //utilc.getVarint32(zIdx, aType[i]);
                        szField = vdbeaux.sqlite3VdbeSerialTypeLen(columnTypes[i]);
                        offsetIntoData += szField;
                        if (offsetIntoData < szField)
                        {
                            ///True if offset overflows 
                            idxHeader = int.MaxValue;
                            ///Forces SQLITE_CORRUPT return below 
                            break;
                        }
                    }
                    else
                    {
                        ///If i is less that nField, then there are less fields in vdbe
                        ///record than SetNumColumns indicated there are columns in the
                        ///table. Set the offset for any extra columns not present in
                        ///the record to 0. vdbe tells code below to store a NULL
                        ///instead of deserializing a value from the record.
                        clumnOffsets[i] = 0;
                    }
                }
                sMem.sqlite3VdbeMemRelease();
                sMem.flags = MemFlags.MEM_Null;
                ///If we have read more header data than was contained in the header,
                ///or if the end of the last field appears to be past the end of the
                ///record, or if the end of the last field appears to be before the end
                ///of the record (when all fields present), then we must be dealing
                ///with a corrupt database.
                if ((idxHeader > idxEndHeader) || (offsetIntoData > payloadSize) || (idxHeader == idxEndHeader && offsetIntoData != payloadSize))
                {
                    rc = sqliteinth.SQLITE_CORRUPT_BKPT();
                    return (SqlResult)ColumnResult.op_column_out;
                }
            }
            ///Get the column information. If aOffset[p2] is non"zero, then
            ///deserialize the value from the record. If aOffset[p2] is zero,
            ///then there are not enough fields in the record to satisfy the">then there are not enough fields in the record to satisfy the</param>
            ///request.  In vdbe case, set the value NULL or to P4 if P4 is">request.  In vdbe case, set the value NULL or to P4 if P4 is</param>
            ///a pointer to a Mem object.
            if (clumnOffsets[clumnNumber_p2] != 0)
            {
                Debug.Assert(rc == SqlResult.SQLITE_OK);
                if (zRecord != null)
                {
                    pDest.sqlite3VdbeMemReleaseExternal();
                    vdbeaux.sqlite3VdbeSerialGet(zRecord, (int)clumnOffsets[clumnNumber_p2], columnTypes[clumnNumber_p2], pDest);
                }
                else
                {
                    len = (int)vdbeaux.sqlite3VdbeSerialTypeLen(columnTypes[clumnNumber_p2]);
                    vdbemem_cs.sqlite3VdbeMemMove(sMem, pDest);
                    rc = vdbemem_cs.sqlite3VdbeMemFromBtree(btCursor, (int)clumnOffsets[clumnNumber_p2], len, vdbeCursor.isIndex, sMem);
                    if (rc != SqlResult.SQLITE_OK)
                    {
                        return (SqlResult)ColumnResult.op_column_out;
                    }
                    zData = sMem.zBLOB;
                    sMem.zBLOB = null;
                    vdbeaux.sqlite3VdbeSerialGet(zData, columnTypes[clumnNumber_p2], pDest);
                }
                pDest.enc = encoding;
            }
            else
            {
                if (pOp.p4type == P4Usage.P4_MEM)
                {
                    vdbemem_cs.sqlite3VdbeMemShallowCopy(pDest, pOp.p4.pMem, MemFlags.MEM_Static);
                }
                else
                {
                    Debug.Assert((pDest.flags & MemFlags.MEM_Null) != 0);
                }
            }
            ///If we dynamically allocated space to hold the data (in the
            ///sqlite3VdbeMemFromBtree() call above) then transfer control of that
            ///dynamically allocated space over to the pDest structure.
            ///vdbe prevents a memory copy.
            //if ( sMem.zMalloc != null )
            //{
            //  Debug.Assert( sMem.z == sMem.zMalloc);
            //  Debug.Assert( sMem.xDel == null );
            //  Debug.Assert( ( pDest.flags & MEM.MEM_Dyn ) == 0 );
            //  Debug.Assert( ( pDest.flags & ( MEM.MEM_Blob | MEM.MEM_Str ) ) == 0 || pDest.z == sMem.z );
            //  pDest.flags &= ~( MEM.MEM_Ephem | MEM.MEM_Static );
            //  pDest.flags |= MEM.MEM_Term;
            //  pDest.z = sMem.z;
            //  pDest.zMalloc = sMem.zMalloc;
            //}
            rc = pDest.sqlite3VdbeMemMakeWriteable();
            op_column_out:
#if SQLITE_TEST
																																																																																																																																				              UPDATE_MAX_BLOBSIZE( pDest );
#endif
            Sqlite3.REGISTER_TRACE(vdbe, pOp.p3, pDest);
            if (zData != null && zData != zRecord)
                malloc_cs.sqlite3_free(ref zData);
            //malloc_cs.sqlite3_free( ref zRec );
            malloc_cs.sqlite3_free(ref sMem);
            return rc;
        }



        //yDbMask 
        private static SqlResult OpCode_ResultRow(Vdbe vdbe,int opcodeIndex, int dataOffset, int columnCount, SqlResult rc, Mem[] memoryBuffer)
        {
            var db = vdbe.db;
            //Mem[] pMem;
            int i;

            ///If vdbe statement has violated immediate foreign key constraints, do
            ///not return the number of rows modified. And do not RELEASE the statement
            ///transaction. It needs to be rolled back.  
            if (SqlResult.SQLITE_OK != (rc = vdbe.sqlite3VdbeCheckFk(0)))
            {
                Debug.Assert((db.flags & SqliteFlags.SQLITE_CountRows) != 0);
                Debug.Assert(vdbe.usesStmtJournal);
                return rc;
            }
            ///If the SQLITE_CountRows flag is set in sqlite3.flags mask, then
            ///DML statements invoke vdbe opcode to return the number of rows
            ///modified to the user. vdbe is the only way that a VM that
            ///opens a statement transaction may invoke vdbe opcode.
            ///
            ///In case vdbe is such a statement, close any statement transaction
            ///opened by vdbe VM before returning control to the user. vdbe is to
            ///<param name="ensure that statement">transactions are always nested, not overlapping.</param>
            ///<param name="If the open statement">transaction is not closed here, then the user</param>
            ///<param name="may step another VM that opens its own statement transaction. vdbe">may step another VM that opens its own statement transaction. vdbe</param>
            ///<param name="may lead to overlapping statement transactions.">may lead to overlapping statement transactions.</param>
            ///<param name=""></param>
            ///<param name="The statement transaction is never a top">level transaction.  Hence</param>
            ///<param name="the RELEASE call below can never fail.">the RELEASE call below can never fail.</param>
            ///<param name=""></param>
            Debug.Assert(vdbe.iStatement == 0 || (db.flags & SqliteFlags.SQLITE_CountRows) != 0);
            rc = vdbe.sqlite3VdbeCloseStatement(sqliteinth.SAVEPOINT_RELEASE);
            if (Sqlite3.NEVER(rc != SqlResult.SQLITE_OK))
            {
                return rc;
            }
            ///Invalidate all ephemeral cursor row caches 
            vdbe.cacheCtr = (vdbe.cacheCtr + 2) | 1;
            ///Make sure the results of the current row are \000 terminated
            ///<param name="and have an assigned type.  The results are de">ephemeralized as</param>
            ///<param name="as side effect.">as side effect.</param>
            ///<param name=""></param>
            //pMem = p.pResultSet = aMem[pOp.p1];
            vdbe.pResultSet = new Mem[columnCount];
            for (i = 0; i < columnCount; i++)
            {
                vdbe.pResultSet[i] = memoryBuffer[dataOffset + i];
                Debug.Assert(vdbe.pResultSet[i].memIsValid());
                //Deephemeralize( p.pResultSet[i] );
                //Debug.Assert( ( p.pResultSet[i].flags & MEM.MEM_Ephem ) == 0
                //        || ( p.pResultSet[i].flags & ( MEM.MEM_Str | MEM.MEM_Blob ) ) == 0 );
                vdbemem_cs.sqlite3VdbeMemNulTerminate(vdbe.pResultSet[i]);
                //sqlite3VdbeMemNulTerminate(pMem[i]);
                Sqlite3.sqlite3VdbeMemStoreType(vdbe.pResultSet[i]);
                Sqlite3.REGISTER_TRACE(vdbe, dataOffset + i, vdbe.pResultSet[i]);
            }
            //      if ( db.mallocFailed != 0 ) goto no_mem;
            ///
            ///<summary>
            ///Return SQLITE_ROW
            ///
            ///</summary>
            vdbe.currentOpCodeIndex = vdbe.opcodeIndex + 1;
            rc = SqlResult.SQLITE_ROW;
            return rc;
        }


        private static void OCode_Compare(Vdbe vdbe,Operation pOp, Mem[] aMem, ref int iCompare, ref int[] aPermute)
        {
            int n;
            int i;
            int p1;
            int p2;
            KeyInfo pKeyInfo;
            int idx;
            CollSeq pColl;
            ///
            ///<summary>
            ///Collating sequence to use on this term 
            ///</summary>
            SortOrder bRev;
            ///
            ///<summary>
            ///True for DESCENDING sort order 
            ///</summary>
            n = pOp.p3;
            pKeyInfo = pOp.p4.pKeyInfo;
            Debug.Assert(n > 0);
            Debug.Assert(pKeyInfo != null);
            p1 = pOp.p1;
            p2 = pOp.p2;
#if SQLITE_DEBUG
																																																																																																																																				              if ( aPermute != null )
              {
                int k, mx = 0;
                for ( k = 0; k < n; k++ )
                  if ( aPermute[k] > mx )
                    mx = aPermute[k];
                Debug.Assert( p1 > 0 && p1 + mx <= p.nMem + 1 );
                Debug.Assert( p2 > 0 && p2 + mx <= p.nMem + 1 );
              }
              else
              {
                Debug.Assert( p1 > 0 && p1 + n <= p.nMem + 1 );
                Debug.Assert( p2 > 0 && p2 + n <= p.nMem + 1 );
              }
#endif
            for (i = 0; i < n; i++)
            {
                idx = aPermute != null ? aPermute[i] : i;
                Debug.Assert(aMem[p1 + idx].memIsValid());
                Debug.Assert(aMem[p2 + idx].memIsValid());
                Sqlite3.REGISTER_TRACE(vdbe, p1 + idx, aMem[p1 + idx]);
                Sqlite3.REGISTER_TRACE(vdbe, p2 + idx, aMem[p2 + idx]);
                Debug.Assert(i < pKeyInfo.nField);
                pColl = pKeyInfo.aColl[i];
                bRev = pKeyInfo.aSortOrder[i];
                iCompare = vdbemem_cs.sqlite3MemCompare(aMem[p1 + idx], aMem[p2 + idx], pColl);
                if (iCompare != 0)
                {
                    if (bRev != 0)
                        iCompare = -iCompare;
                    break;
                }
            }
            aPermute = null;
        }



    }
}
